{"meta":{"title":"Stay Hungry Stay Foolish","subtitle":"","description":"","author":"理性乐观π","url":"https://tony2ty.github.io","root":"/"},"pages":[{"title":"about","date":"2021-07-04T11:18:01.000Z","updated":"2021-07-04T12:22:29.147Z","comments":true,"path":"about/index.html","permalink":"https://tony2ty.github.io/about/index.html","excerpt":"","text":"这里分享嵌入式软件开发中的学习总结"},{"title":"achives","date":"2021-07-04T11:30:07.000Z","updated":"2021-07-04T11:30:07.870Z","comments":true,"path":"achives/index.html","permalink":"https://tony2ty.github.io/achives/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-07-04T11:15:06.000Z","updated":"2021-07-04T11:16:14.655Z","comments":true,"path":"categories/index.html","permalink":"https://tony2ty.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-04T11:16:36.000Z","updated":"2021-07-04T11:16:54.139Z","comments":true,"path":"tags/index.html","permalink":"https://tony2ty.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"imx6ull移植mosquitto错误解决","slug":"imx6ull移植mosquitto错误解决","date":"2021-10-21T13:44:39.000Z","updated":"2021-10-21T13:46:46.049Z","comments":true,"path":"2021/10/21/imx6ull移植mosquitto错误解决/","link":"","permalink":"https://tony2ty.github.io/2021/10/21/imx6ull%E7%A7%BB%E6%A4%8Dmosquitto%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/","excerpt":"","text":"错误提示 relocation R_ARM_THM_MOVW_ABS_NC against `a local symbol’ can not be used when making a shared object; recompile with -fPIC 通过网络搜索确认是编译的openssl库文件存在问题，即增加-fPIC选项重新编译即可通过。 CFLAG标志增加-fPIC选项","categories":[{"name":"嵌入式Linux","slug":"嵌入式Linux","permalink":"https://tony2ty.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"}],"tags":[{"name":"IMX6ULL","slug":"IMX6ULL","permalink":"https://tony2ty.github.io/tags/IMX6ULL/"}]},{"title":"STM32G070接收北斗数据异常问题","slug":"STM32G070接收北斗数据异常问题","date":"2021-10-13T06:32:45.000Z","updated":"2021-10-13T07:12:12.361Z","comments":true,"path":"2021/10/13/STM32G070接收北斗数据异常问题/","link":"","permalink":"https://tony2ty.github.io/2021/10/13/STM32G070%E6%8E%A5%E6%94%B6%E5%8C%97%E6%96%97%E6%95%B0%E6%8D%AE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题STM32G070接收华大北斗模块报文，数据有丢失。 硬件环境STM32G070 华大北斗模块 华大北斗模块使用STM32G070的USART3接口 软件USART3接口配置 使用DMA配合USART3的IDLE中断实现。 串口报文 完整北斗报文（定位成功）大概在1089字节左右。 实际波形使用逻辑分析仪测试波形如下。上面的波形是北斗模块数据，下图是USART3 IDLE中断服务程序内GPIO翻转波形（进入IDLE中断后GPIO引脚电平翻转一次）。正常情况下应该是下图中左边部分，即在收到整包北斗数据后USART3产生IDLE中断。 上图中右边部分是北斗模块没有将数据一次发送，导致USART3在接收数据过程中产生了IDLE中断。 分析解决波形放大后发现，USART3接收北斗数据报文过程中产生IDLE中断时，报文两个字节之间相差100us左右。即IDLE中断服务程序执行时间超过100us（需要在中断服务程序中禁止DMA传输，然后将数据入队处理），这个明显不合理。 检查USART3的IDLE中断服务程序发现内部存在memset函数（内存操作类函数比较耗时）。注释该函数之后，测试丢数据现象好转，但还是存在丢数据的问题，最后提高系统主频至64M（原来只有16M），经测试接收正常。 该memset操作实际为多于操作，注释改行代码对程序无影响。 总结在中断服务程序中不要加入耗时操作（针对内存的操作）。","categories":[{"name":"STM32","slug":"STM32","permalink":"https://tony2ty.github.io/categories/STM32/"}],"tags":[{"name":"GPS","slug":"GPS","permalink":"https://tony2ty.github.io/tags/GPS/"}]},{"title":"3的幂","slug":"3的幂","date":"2021-09-24T00:33:38.000Z","updated":"2021-09-24T00:35:50.213Z","comments":true,"path":"2021/09/24/3的幂/","link":"","permalink":"https://tony2ty.github.io/2021/09/24/3%E7%9A%84%E5%B9%82/","excerpt":"","text":"326. 3的幂难度：简单 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x 示例 1： 输入：n = 27 输出：true 示例 2： 输入：n = 0 输出：false 示例 3： 输入：n = 9 输出：true 示例 4： 输入：n = 45 输出：false 提示： -231 &lt;= n &lt;= 231 - 1 进阶： 你能不使用循环或者递归来完成本题吗？ 通过次数132,712 提交次数263,322 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ bool isPowerOfThree(int n){ int a = 0; if (n == 1) { return true; } while (n != 0) { a = n % 3; n /= 3; if ((n == 1) || (a != 0)) { break; } } if (n == 1 &amp;&amp; a == 0) { return true; } return false; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"颠倒二进制位","slug":"颠倒二进制位","date":"2021-09-22T05:26:19.000Z","updated":"2021-09-22T05:28:21.141Z","comments":true,"path":"2021/09/22/颠倒二进制位/","link":"","permalink":"https://tony2ty.github.io/2021/09/22/%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/","excerpt":"","text":"190. 颠倒二进制位难度：简单 颠倒给定的 32 位无符号整数的二进制位。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 示例 1： 输入：n = 00000010100101000001111010011100 输出：964176192 (00111001011110000010100101000000) 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 输入：n = 11111111111111111111111111111101 输出：3221225471 (10111111111111111111111111111111) 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 提示： 输入是一个长度为 32 的二进制字符串 通过次数130,497 提交次数187,149 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ uint32_t reverseBits(uint32_t n) { uint32_t val = 0; int i; for (i = 0; i &lt; 32; i++) { if ((n >> i) &amp; 0x01) { val += 0x01; } // printf(\"%d %x\\n\", (n >> i) &amp; 0x01, val); if (i != 31) { val &lt;&lt;= 1; } } return val; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"位1的个数","slug":"位1的个数","date":"2021-09-22T00:44:20.000Z","updated":"2021-09-22T00:45:57.125Z","comments":true,"path":"2021/09/22/位1的个数/","link":"","permalink":"https://tony2ty.github.io/2021/09/22/%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"","text":"191. 位1的个数难度：简单 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。 示例 2： 输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。 示例 3： 输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。 提示： 输入必须是长度为 32 的 二进制串 。 进阶： 如果多次调用这个函数，你将如何优化你的算法？ 通过次数188,460 提交次数251,807 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int hammingWeight(uint32_t n) { int val = 0; for (int i = 0; i &lt; 32; i++) { if ((n >> i) &amp; 0x01) { val++; } } return val; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"至少是其他数字两倍的最大数","slug":"至少是其他数字两倍的最大数","date":"2021-09-19T12:52:07.000Z","updated":"2021-09-19T12:54:59.832Z","comments":true,"path":"2021/09/19/至少是其他数字两倍的最大数/","link":"","permalink":"https://tony2ty.github.io/2021/09/19/%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/","excerpt":"","text":"747. 至少是其他数字两倍的最大数难度：简单 给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。 请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。 示例 1： 输入：nums = [3,6,1,0] 输出：1 解释：6 是最大的整数，对于数组中的其他整数，6 大于数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。 示例 2： 输入：nums = [1,2,3,4] 输出：-1 解释：4 没有超过 3 的两倍大，所以返回 -1 。 示例 3： 输入：nums = [1] 输出：0 解释：因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。 提示： 1 &lt;= nums.length &lt;= 50 0 &lt;= nums[i] &lt;= 100 nums 中的最大元素是唯一的 通过次数45,043 提交次数108,352 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int dominantIndex(int* nums, int numsSize){ int max, min, index = -1; if (numsSize == 1) { return 0; } max = min = -1; for (int i = 0; i &lt; numsSize; i++) { if (nums[i] > max) { min = max; max = nums[i]; index = i; } else if (nums[i] > min) { min = nums[i]; } } if (max / 2 >= min) { return index; } return -1; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"最小时间差","slug":"最小时间差","date":"2021-09-18T09:11:39.000Z","updated":"2021-09-18T09:19:47.323Z","comments":true,"path":"2021/09/18/最小时间差/","link":"","permalink":"https://tony2ty.github.io/2021/09/18/%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE/","excerpt":"","text":"539. 最小时间差难度：中等 给定一个 24 小时制（小时:分钟 **”HH:MM”**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。 示例 1： 输入：timePoints = [&quot;23:59&quot;,&quot;00:00&quot;] 输出：1 示例 2： 输入：timePoints = [&quot;00:00&quot;,&quot;23:59&quot;,&quot;00:00&quot;] 输出：0 提示： 2 &lt;= timePoints &lt;= 2 * 104 timePoints[i] 格式为 “HH:MM” 通过次数13,788 提交次数23,121 int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int findMinDifference(char ** timePoints, int timePointsSize){ int array[timePointsSize]; int hour, minute; for (int i = 0; i &lt; timePointsSize; i++) { sscanf(timePoints[i], \"%d:%d\", &amp;hour, &amp;minute); array[i] = hour * 60 + minute; } qsort(array, timePointsSize, sizeof(int), cmpfunc); int min = array[1] - array[0]; for (int i = 2; i &lt; timePointsSize; i++) { if (min > (array[i] - array[i - 1])) { min = array[i] - array[i - 1]; } } int diff = array[0] + 1440 - array[timePointsSize - 1]; if (diff &lt; min) { min = diff; } return min; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"STM32F429PWM输出","slug":"STM32F429PWM输出","date":"2021-09-17T00:31:17.000Z","updated":"2021-09-17T00:42:53.729Z","comments":true,"path":"2021/09/17/STM32F429PWM输出/","link":"","permalink":"https://tony2ty.github.io/2021/09/17/STM32F429PWM%E8%BE%93%E5%87%BA/","excerpt":"","text":"硬件 NUCLEO-F429ZI开发板 软件 KEIL LL库 STM32CubeMX配置 代码 void MX_TIM1_Init(uint32_t period, uint32_t pulse) { if (LL_TIM_GetAutoReload(TIM1) == (period - 1) &amp;&amp; LL_TIM_OC_GetCompareCH1(TIM1) == (pulse - 1)) { return; } /* USER CODE BEGIN TIM1_Init 0 */ uint32_t uhPrescalerValue = 0; uhPrescalerValue = (uint32_t)(SystemCoreClock / 1200) - 1; // 60000 - 1 ¼´1.2K // LL_TIM_DeInit(TIM1); /* USER CODE END TIM1_Init 0 */ LL_TIM_InitTypeDef TIM_InitStruct = {0}; LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0}; LL_TIM_BDTR_InitTypeDef TIM_BDTRInitStruct = {0}; LL_GPIO_InitTypeDef GPIO_InitStruct = {0}; /* Peripheral clock enable */ LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM1); /* USER CODE BEGIN TIM1_Init 1 */ /* USER CODE END TIM1_Init 1 */ TIM_InitStruct.Prescaler = uhPrescalerValue; TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP; TIM_InitStruct.Autoreload = (period &lt;= 1)? 0 : (period - 1); TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1; TIM_InitStruct.RepetitionCounter = 0; LL_TIM_Init(TIM1, &amp;TIM_InitStruct); LL_TIM_DisableARRPreload(TIM1); LL_TIM_OC_EnablePreload(TIM1, LL_TIM_CHANNEL_CH1); TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM1; TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE; TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE; TIM_OC_InitStruct.CompareValue = (pulse &lt;= 1)? 0 : (pulse - 1); TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH; TIM_OC_InitStruct.OCNPolarity = LL_TIM_OCPOLARITY_HIGH; TIM_OC_InitStruct.OCIdleState = LL_TIM_OCIDLESTATE_LOW; TIM_OC_InitStruct.OCNIdleState = LL_TIM_OCIDLESTATE_LOW; LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH1, &amp;TIM_OC_InitStruct); LL_TIM_OC_DisableFast(TIM1, LL_TIM_CHANNEL_CH1); LL_TIM_SetTriggerOutput(TIM1, LL_TIM_TRGO_RESET); LL_TIM_DisableMasterSlaveMode(TIM1); TIM_BDTRInitStruct.OSSRState = LL_TIM_OSSR_DISABLE; TIM_BDTRInitStruct.OSSIState = LL_TIM_OSSI_DISABLE; TIM_BDTRInitStruct.LockLevel = LL_TIM_LOCKLEVEL_OFF; TIM_BDTRInitStruct.DeadTime = 0; TIM_BDTRInitStruct.BreakState = LL_TIM_BREAK_DISABLE; TIM_BDTRInitStruct.BreakPolarity = LL_TIM_BREAK_POLARITY_HIGH; TIM_BDTRInitStruct.AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE; LL_TIM_BDTR_Init(TIM1, &amp;TIM_BDTRInitStruct); /* USER CODE BEGIN TIM1_Init 2 */ /* USER CODE END TIM1_Init 2 */ LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOE); /**TIM1 GPIO Configuration PE9 ------> TIM1_CH1 */ GPIO_InitStruct.Pin = LL_GPIO_PIN_9; GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE; GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL; GPIO_InitStruct.Pull = LL_GPIO_PULL_NO; GPIO_InitStruct.Alternate = LL_GPIO_AF_1; LL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct); /**************************/ /* TIM2 interrupts set-up */ /**************************/ /* Enable the capture/compare interrupt for channel 1*/ // LL_TIM_EnableIT_CC1(TIM1); LL_TIM_EnableAllOutputs(TIM1); /**********************************/ /* Start output signal generation */ /**********************************/ /* Enable output channel 1 */ LL_TIM_CC_EnableChannel(TIM1, LL_TIM_CHANNEL_CH1); /* Enable counter */ LL_TIM_EnableCounter(TIM1); /* Force update generation */ LL_TIM_GenerateEvent_UPDATE(TIM1); } 问题 PWM输出占空比100%异常的问题 将ton与period周期值设置相同后，通过逻辑分析仪测试发现占空比无法达到100%。查看手册可知需要将ton（CCRx）大于period（ARR）周期值才能输出占空比100%。 PWM输出的最大频率问题 PWM输出的最大频率即为TIMER所在总线频率/定时器的分频系数。如果TIMER是16位，频率基本没法超过1Hz。此时应该考虑使用32位TIMER。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://tony2ty.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"STM32","permalink":"https://tony2ty.github.io/categories/STM32/"}],"tags":[{"name":"TIMER","slug":"TIMER","permalink":"https://tony2ty.github.io/tags/TIMER/"},{"name":"PWM","slug":"PWM","permalink":"https://tony2ty.github.io/tags/PWM/"}]},{"title":"剑指OfferII068.查找插入位置","slug":"剑指OfferII068-查找插入位置","date":"2021-09-17T00:09:27.000Z","updated":"2021-09-17T00:11:06.054Z","comments":true,"path":"2021/09/17/剑指OfferII068-查找插入位置/","link":"","permalink":"https://tony2ty.github.io/2021/09/17/%E5%89%91%E6%8C%87OfferII068-%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"剑指 Offer II 068. 查找插入位置难度：简单 给定一个排序的整数数组 nums 和一个整数目标值 target ，请在数组中找到 target ，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 示例 4: 输入: nums = [1,3,5,6], target = 0 输出: 0 示例 5: 输入: nums = [1], target = 0 输出: 0 提示: 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 为无重复元素的升序排列数组 -104 &lt;= target &lt;= 104 注意：本题与主站 35 题相同： https://leetcode-cn.com/problems/search-insert-position/ 通过次数1,826 提交次数3,538 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int searchInsert(int* nums, int numsSize, int target){ if (nums == NULL) { return 0; } if (target &lt; nums[0]) { return 0; } if (target > nums[numsSize - 1]) { return numsSize; } int ret = 0; for (int i = 0; i &lt; numsSize; i++) { if (target == nums[i]) { ret = i; break; } else if (target &lt; nums[i]) { ret = i; break; } } return ret; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指OfferII069.山峰数组的顶部","slug":"剑指OfferII069-山峰数组的顶部","date":"2021-09-16T00:26:40.000Z","updated":"2021-09-16T00:29:33.243Z","comments":true,"path":"2021/09/16/剑指OfferII069-山峰数组的顶部/","link":"","permalink":"https://tony2ty.github.io/2021/09/16/%E5%89%91%E6%8C%87OfferII069-%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%B6%E9%83%A8/","excerpt":"","text":"剑指 Offer II 069. 山峰数组的顶部难度：简单 符合下列属性的数组 arr 称为 山峰数组（山脉数组） ： arr.length &gt;= 3 存在 i （ 0 &lt; i &lt; arr.length - 1 ）使得： arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1] 给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。 示例 1： 输入：arr = [0,1,0] 输出：1 示例 2： 输入：arr = [1,3,5,4,2] 输出：2 示例 3： 输入：arr = [0,10,5,2] 输出：1 示例 4： 输入：arr = [3,4,5,1] 输出：2 示例 5： 输入：arr = [24,69,100,99,79,78,67,36,26,19] 输出：2 提示： 3 &lt;= arr.length &lt;= 104 0 &lt;= arr[i] &lt;= 106 题目数据保证 arr 是一个山脉数组 进阶：很容易想到时间复杂度 O(n) 的解决方案，你可以设计一个 O(log(n)) 的解决方案吗？ 注意：本题与主站 852 题相同：https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/ 通过次数1,754 提交次数2,410 性能分析 时间复杂度：$O(logn)$​​​​ 空间复杂度：$O(1)$ int peakIndexInMountainArray(int* arr, int arrSize){ int index = 1; int low = 0; int high = arrSize - 1; int mid = 0; while(low &lt;= high) { mid = low + ((high - low) >> 1); // printf(\"%d %d %d\\r\\n\", mid, low, high); if (arr[mid] > arr[mid - 1] &amp;&amp; arr[mid] > arr[mid + 1]) { index = mid; break; } else { if (arr[mid - 1] > arr[mid + 1]) { high = mid; } else if (arr[mid - 1] &lt; arr[mid + 1]) { low = mid; } } } return index; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"}]},{"title":"最大升序子数组和","slug":"最大升序子数组和","date":"2021-09-15T15:54:02.000Z","updated":"2021-09-16T00:29:54.456Z","comments":true,"path":"2021/09/15/最大升序子数组和/","link":"","permalink":"https://tony2ty.github.io/2021/09/15/%E6%9C%80%E5%A4%A7%E5%8D%87%E5%BA%8F%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","excerpt":"","text":"1800. 最大升序子数组和难度：简单 给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。 子数组是数组中的一个连续数字序列。 已知子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，若对所有 i（l &lt;= i &lt; r），numsi &lt; numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。 示例 1： 输入：nums = [10,20,30,5,10,50] 输出：65 解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。 示例 2： 输入：nums = [10,20,30,40,50] 输出：150 解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 示例 3： 输入：nums = [12,17,15,13,10,11,12] 输出：33 解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。 示例 4： 输入：nums = [100,10,1] 输出：100 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 通过次数9,510 提交次数13,903 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int maxAscendingSum(int* nums, int numsSize){ int val = nums[0]; int max = val; for (int i = 1; i &lt; numsSize; i++) { if (nums[i] > nums[i - 1]) { val += nums[i]; } else { if (val > max) { max = val; } val = nums[i]; } } if (max &lt; val) { max = val; } return max; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"162.寻找峰值","slug":"162-寻找峰值","date":"2021-09-14T01:16:41.000Z","updated":"2021-09-14T01:18:48.028Z","comments":true,"path":"2021/09/14/162-寻找峰值/","link":"","permalink":"https://tony2ty.github.io/2021/09/14/162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/","excerpt":"","text":"162. 寻找峰值难度中等513收藏分享切换为英文接收动态反馈 峰值元素是指其值严格大于左右相邻值的元素。 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞ 。 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。 示例 1： 输入：nums = [1,2,3,1] 输出：2 解释：3 是峰值元素，你的函数应该返回其索引 2。 示例 2： 输入：nums = [1,2,1,3,5,6,4] 输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 提示： 1 &lt;= nums.length &lt;= 1000 -231 &lt;= nums[i] &lt;= 231 - 1 对于所有有效的 i 都有 nums[i] != nums[i + 1] 通过次数124,797 提交次数252,164 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int findPeakElement(int* nums, int numsSize){ int mid = 0; int low = 0, high = numsSize; if (numsSize == 1) { return 0; } else if (numsSize == 2) { if (nums[0] > nums[1]) { return 0; } else { return 1; } } while(low &lt;= high) { mid = low + ((high - low) >> 1); // printf(\"%d\\n\", mid); if ((mid - 1) &lt; 0 || (mid + 1) >= numsSize) { break; } if (nums[mid - 1] > nums[mid] &amp;&amp; nums[mid] > nums[mid + 1]) { high = mid; } else if ((nums[mid - 1] &lt; nums[mid] &amp;&amp; nums[mid] &lt; nums[mid + 1]) || (nums[mid - 1] > nums[mid] &amp;&amp; nums[mid] &lt; nums[mid + 1])) { low = mid; } else { return mid; } } return mid; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"}]},{"title":"寻找旋转排序数组中的最小值II","slug":"寻找旋转排序数组中的最小值II","date":"2021-09-13T00:17:33.000Z","updated":"2021-09-13T00:19:21.738Z","comments":true,"path":"2021/09/13/寻找旋转排序数组中的最小值II/","link":"","permalink":"https://tony2ty.github.io/2021/09/13/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/","excerpt":"","text":"154. 寻找旋转排序数组中的最小值 II难度：困难 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4] 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 示例 1： 输入：nums = [1,3,5] 输出：1 示例 2： 输入：nums = [2,2,2,0,1] 输出：0 提示： n == nums.length 1 &lt;= n &lt;= 5000 -5000 &lt;= nums[i] &lt;= 5000 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 进阶： 这道题是 寻找旋转排序数组中的最小值 的延伸题目。 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？ 通过次数111,363 提交次数209,361 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int findMin(int* nums, int numsSize){ int min = nums[0]; for (int i = 1; i &lt; numsSize; i++) { if (nums[i] &lt; min) { min = nums[i]; } } return min; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"寻找旋转排序数组中的最小值","slug":"寻找旋转排序数组中的最小值","date":"2021-09-12T10:50:06.000Z","updated":"2021-09-12T10:52:28.637Z","comments":true,"path":"2021/09/12/寻找旋转排序数组中的最小值/","link":"","permalink":"https://tony2ty.github.io/2021/09/12/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","excerpt":"","text":"153. 寻找旋转排序数组中的最小值难度：中等 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 示例 1： 输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2： 输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3： 输入：nums = [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 提示： n == nums.length 1 &lt;= n &lt;= 5000 -5000 &lt;= nums[i] &lt;= 5000 nums 中的所有整数 互不相同 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 通过次数206,363 提交次数364,472 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int findMin(int* nums, int numsSize){ int min = nums[0]; for (int i = 1; i &lt; numsSize; i++) { if (nums[i] &lt; min) { min = nums[i]; } } return min; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"子数组最大平均数I","slug":"子数组最大平均数I","date":"2021-09-11T00:17:22.000Z","updated":"2021-09-11T00:19:39.919Z","comments":true,"path":"2021/09/11/子数组最大平均数I/","link":"","permalink":"https://tony2ty.github.io/2021/09/11/%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0I/","excerpt":"","text":"643. 子数组最大平均数 I难度：简单 给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。 请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。 任何误差小于 10-5 的答案都将被视为正确答案。 示例 1： 输入：nums = [1,12,-5,-6,50,3], k = 4 输出：12.75 解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 示例 2： 输入：nums = [5], k = 1 输出：5.00000 提示： n == nums.length 1 &lt;= k &lt;= n &lt;= 105 -104 &lt;= nums[i] &lt;= 104 通过次数62,310 提交次数137,971 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ double findMaxAverage(int* nums, int numsSize, int k){ int val, max; val = 0; for (int i = 0; i &lt; k; i++) { val += nums[i]; } max = val; for (int i = k; i &lt; numsSize; i++) { val -= nums[i - k]; val += nums[i]; // printf(\"%d %d %d %d\\n\", val, max, nums[i - k], nums[i]); if (max &lt; val) { max = val; } } return (double)max / k; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"最小差值I","slug":"最小差值I","date":"2021-09-10T13:13:43.000Z","updated":"2021-09-10T13:16:03.905Z","comments":true,"path":"2021/09/10/最小差值I/","link":"","permalink":"https://tony2ty.github.io/2021/09/10/%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BCI/","excerpt":"","text":"908. 最小差值 I难度：简单 给你一个整数数组 nums，请你给数组中的每个元素 nums[i] 都加上一个任意数字 x （-k &lt;= x &lt;= k），从而得到一个新数组 result 。 返回数组 result 的最大值和最小值之间可能存在的最小差值。 示例 1： 输入：nums = [1], k = 0 输出：0 解释：result = [1] 示例 2： 输入：nums = [0,10], k = 2 输出：6 解释：result = [2,8] 示例 3： 输入：nums = [1,3,6], k = 3 输出：0 解释：result = [3,3,3] or result = [4,4,4] 提示： 1 &lt;= nums.length &lt;= 10000 0 &lt;= nums[i] &lt;= 10000 0 &lt;= k &lt;= 10000 通过次数20,355 提交次数29,134 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int smallestRangeI(int* nums, int numsSize, int k){ int max, min; max = min = nums[0]; for (int i = 0; i < numsSize; i++) { if (nums[i] > max) { max = nums[i]; } else if (nums[i] < min) { min = nums[i]; } } if ((max - min) < 2 * k) { return 0; } else { return max - min - 2 * k; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"删除有序数组中的重复项II","slug":"删除有序数组中的重复项II","date":"2021-09-09T02:57:49.000Z","updated":"2021-09-09T03:07:56.633Z","comments":true,"path":"2021/09/09/删除有序数组中的重复项II/","link":"","permalink":"https://tony2ty.github.io/2021/09/09/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/","excerpt":"","text":"80. 删除有序数组中的重复项 II难度：中等 给你一个有序数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 说明： 为什么返回数值是整数，但输出的答案是数组呢？ 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125; 示例 1： 输入：nums = [1,1,1,2,2,3] 输出：5, nums = [1,1,2,2,3] 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。 示例 2： 输入：nums = [0,0,1,1,1,1,2,3,3] 输出：7, nums = [0,0,1,1,2,3,3] 解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。 提示： 1 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按升序排列 通过次数145,544 提交次数236,114 性能分析 时间复杂度：$O(n)？$​​​​ 空间复杂度：$O(1)$ int removeDuplicates(int* nums, int numsSize){ int cnt = numsSize; int val = nums[0]; int tmp = 1; for (int i = 1; i &lt; cnt; i++) //注意这里的结束条件不能是numsSize，数组长度在动态变化 { if (nums[i] == val) { tmp++; // printf(\"a %d %d %d\\n\", tmp, val, i); } else { if (tmp > 2) { int j, k; for (j = i - tmp + 2, k = i; k &lt; numsSize; j++, k++) { nums[j] = nums[k]; } cnt -= tmp - 2; i = i - tmp + 2; val = nums[i]; tmp = 1; } else { val = nums[i]; tmp = 1; // printf(\"b %d %d %d\\n\", tmp, val, i); } // printf(\"c %d %d %d\\n\", tmp, val, i); } } // printf(\"%d\\n\", tmp); if (tmp > 2) { cnt -= tmp - 2; } return cnt; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer53-I.在排序数组中查找数字I","slug":"剑指Offer53-I-在排序数组中查找数字I","date":"2021-09-08T00:47:21.000Z","updated":"2021-09-08T00:48:49.441Z","comments":true,"path":"2021/09/08/剑指Offer53-I-在排序数组中查找数字I/","link":"","permalink":"https://tony2ty.github.io/2021/09/08/%E5%89%91%E6%8C%87Offer53-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I/","excerpt":"","text":"剑指 Offer 53 - I. 在排序数组中查找数字 I难度：简单 统计一个数字在排序数组中出现的次数。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8 输出: 2 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6 输出: 0 提示： 0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 注意：本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/ 通过次数179,015 提交次数332,211 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int search(int* nums, int numsSize, int target){ int cnt = 0; for (int i = 0; i &lt; numsSize; i++) { if (nums[i] == target) { cnt++; } } return cnt; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"三个数的最大乘积","slug":"三个数的最大乘积","date":"2021-09-07T06:15:47.000Z","updated":"2021-09-07T06:28:54.006Z","comments":true,"path":"2021/09/07/三个数的最大乘积/","link":"","permalink":"https://tony2ty.github.io/2021/09/07/%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/","excerpt":"","text":"628. 三个数的最大乘积难度：简单 给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1： 输入：nums = [1,2,3] 输出：6 示例 2： 输入：nums = [1,2,3,4] 输出：24 示例 3： 输入：nums = [-1,-2,-3] 输出：-6 提示： 3 &lt;= nums.length &lt;= 104 -1000 &lt;= nums[i] &lt;= 1000 通过次数78,488 提交次数149,433 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int maximumProduct(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), cmpfunc); int val1 = 0,val2 = 0; if ((nums[0] &lt; 0) &amp;&amp; (nums[1] &lt; 0)) { val1 = nums[0] * nums[1]; } val1 *= nums[numsSize - 1]; val2 = nums[numsSize - 1] * nums[numsSize - 2] * nums[numsSize - 3]; return (val1 > val2)? val1 : val2; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"存在连续三个奇数的数组","slug":"存在连续三个奇数的数组","date":"2021-09-06T01:19:10.000Z","updated":"2021-09-06T01:22:39.086Z","comments":true,"path":"2021/09/06/存在连续三个奇数的数组/","link":"","permalink":"https://tony2ty.github.io/2021/09/06/%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84/","excerpt":"","text":"1550. 存在连续三个奇数的数组难度：简单 给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。 示例 1： 输入：arr = [2,6,4,1] 输出：false 解释：不存在连续三个元素都是奇数的情况。 示例 2： 输入：arr = [1,2,34,3,4,5,7,23,12] 输出：true 解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。 提示： 1 &lt;= arr.length &lt;= 1000 1 &lt;= arr[i] &lt;= 1000 通过次数20,766 提交次数31,444 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ bool threeConsecutiveOdds(int* arr, int arrSize){ int cnt = 0; for (int i = 0; i &lt; arrSize; i++) { if (arr[i] % 2 == 1) { cnt++; if (cnt >= 3) { return true; } } else { cnt = 0; } } return false; } 代码优化 bool threeConsecutiveOdds(int* arr, int arrSize){ int cnt = 0; for (int i = 0; i &lt; arrSize; i++) { if (arr[i] &amp; 0x01) { cnt++; if (cnt >= 3) { return true; } } else { cnt = 0; } } return false; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"有序数组中出现次数超过25%的元素","slug":"有序数组中出现次数超过25-的元素","date":"2021-09-06T00:25:16.000Z","updated":"2021-09-06T00:29:09.663Z","comments":true,"path":"2021/09/06/有序数组中出现次数超过25-的元素/","link":"","permalink":"https://tony2ty.github.io/2021/09/06/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%8725-%E7%9A%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"1287. 有序数组中出现次数超过25%的元素难度：简单 给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。 请你找到并返回这个整数 示例： 输入：arr = [1,2,2,6,6,6,6,7,10] 输出：6 提示： 1 &lt;= arr.length &lt;= 10^4 0 &lt;= arr[i] &lt;= 10^5 通过次数15,089 提交次数24,941 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int findSpecialInteger(int* arr, int arrSize){ int val = arr[0]; int cnt = 0; for (int i = 1; i &lt; arrSize; i++) { if (val == arr[i]) { cnt++; if (cnt >= arrSize / 4) { break; } } else { val = arr[i]; cnt = 0; } } return val; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"第三大的数","slug":"第三大的数","date":"2021-09-04T01:35:49.000Z","updated":"2021-09-04T01:38:46.836Z","comments":true,"path":"2021/09/04/第三大的数/","link":"","permalink":"https://tony2ty.github.io/2021/09/04/%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/","excerpt":"","text":"414. 第三大的数难度简单243收藏分享切换为英文接收动态反馈 给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。 示例 1： 输入：[3, 2, 1] 输出：1 解释：第三大的数是 1 。 示例 2： 输入：[1, 2] 输出：2 解释：第三大的数不存在, 所以返回最大的数 2 。 示例 3： 输入：[2, 2, 3, 1] 输出：1 解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。 此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。 提示： 1 &lt;= nums.length &lt;= 104 -231 &lt;= nums[i] &lt;= 231 - 1 进阶：你能设计一个时间复杂度 O(n) 的解决方案吗？ 通过次数59,399 提交次数162,929 性能分析 时间复杂度：$O(n^2)$​​​​ 空间复杂度：$O(1)$ int thirdMax(int* nums, int numsSize){ int array[3]; int index = 2; int temp; for (int i = 0; i &lt; numsSize-1; i++) { for (int j = 0; j &lt; numsSize-1-i; j++) { if(nums[j]>nums[j+1]) { temp=nums[j]; nums[j]=nums[j+1]; nums[j+1]=temp; } } } array[index] = nums[numsSize - 1]; for (int i = numsSize - 2; i >= 0; i--) { // printf(\"%d %d\\n\", nums[i], array[index]); if (nums[i] &lt; array[index]) { if (index >= 1) { array[--index] = nums[i]; } } } if (index == 0) { return array[0]; } else { return array[2]; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://tony2ty.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"}]},{"title":"剑指Offer39.数组中出现次数超过一半的数字","slug":"剑指Offer39-数组中出现次数超过一半的数字","date":"2021-09-03T01:04:14.000Z","updated":"2021-09-03T01:08:31.197Z","comments":true,"path":"2021/09/03/剑指Offer39-数组中出现次数超过一半的数字/","link":"","permalink":"https://tony2ty.github.io/2021/09/03/%E5%89%91%E6%8C%87Offer39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"剑指 Offer 39. 数组中出现次数超过一半的数字难度：简单 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2 限制： 1 &lt;= 数组长度 &lt;= 50000 注意：本题与主站 169 题相同：https://leetcode-cn.com/problems/majority-element/ 通过次数159,112 提交次数230,800 性能分析 时间复杂度：$O(nlogn)$​​​​ 空间复杂度：$O(1)$ int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int majorityElement(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), cmpfunc); return nums[numsSize/2]; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"快速排序","slug":"快速排序","permalink":"https://tony2ty.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"在排序数组中查找元素的第一个和最后一个位置","slug":"在排序数组中查找元素的第一个和最后一个位置","date":"2021-09-02T13:12:04.000Z","updated":"2021-09-03T01:15:18.345Z","comments":true,"path":"2021/09/02/在排序数组中查找元素的第一个和最后一个位置/","link":"","permalink":"https://tony2ty.github.io/2021/09/02/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"34. 在排序数组中查找元素的第一个和最后一个位置难度：中等 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示： 0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 通过次数324,118 提交次数763,852 性能分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* searchRange(int* nums, int numsSize, int target, int* returnSize){ int i, j; int start, end; int *array = malloc(sizeof(int) * 2); *returnSize = 2; array[0] = -1; array[1] = -1; if (numsSize == 0 || target &lt; nums[0] || target > nums[numsSize - 1]) { return array; } start = end = -1; for (i = 0; i &lt; numsSize; i++) { if (nums[i] == target) { start = i; for (int j = i + 1; j &lt; numsSize; j++) { if (nums[j] == target) { end = j; } } break; } } if (start != -1 &amp;&amp; end != -1) { array[0] = start; array[1] = end; } else if (start != -1 &amp;&amp; end == -1) { array[0] = start; array[1] = start; } return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指Offer22.链表中倒数第k个节点","slug":"剑指Offer22-链表中倒数第k个节点","date":"2021-09-02T01:24:08.000Z","updated":"2021-09-02T01:28:46.057Z","comments":true,"path":"2021/09/02/剑指Offer22-链表中倒数第k个节点/","link":"","permalink":"https://tony2ty.github.io/2021/09/02/%E5%89%91%E6%8C%87Offer22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"剑指 Offer 22. 链表中倒数第k个节点难度：简单 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 通过次数222,429 提交次数280,854 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* getKthFromEnd(struct ListNode* head, int k){ int cnt = 0, target = 0; struct ListNode *plist = head; while (head != NULL) { cnt++; head = head->next; } // printf(\"%d\\n\", cnt); if (k > cnt) { return NULL; } target = cnt - k; while (target != 0) { plist = plist->next; target--; } return plist; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"剑指OfferII075.数组相对排序","slug":"剑指OfferII075-数组相对排序","date":"2021-09-01T14:34:34.000Z","updated":"2021-09-01T14:38:05.114Z","comments":true,"path":"2021/09/01/剑指OfferII075-数组相对排序/","link":"","permalink":"https://tony2ty.github.io/2021/09/01/%E5%89%91%E6%8C%87OfferII075-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"剑指 Offer II 075. 数组相对排序难度：简单 给定两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： 1 &lt;= arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 注意：本题与主站 1122 题相同：https://leetcode-cn.com/problems/relative-sort-array/ 通过次数894 提交次数1,246 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(n)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize){ int array[1001] = {0}; for (int i = 0; i &lt; arr1Size; i++) { array[arr1[i]]++; } int cnt = 0; for (int i = 0; i &lt; arr2Size; i++) { for (int j = 0; j &lt; array[arr2[i]]; j++) { arr1[cnt++] = arr2[i]; } array[arr2[i]] = 0; } for (int i = 0; i &lt; 1001; i++) { if (array[i] == 0) { continue; } // printf(\"%d %d\\n\", i, array[i]); for (int j = 0; j &lt; array[i]; j++) { arr1[cnt++] = i; } } *returnSize = arr1Size; return arr1; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"}]},{"title":"剑指Offer03.数组中重复的数字","slug":"剑指Offer03-数组中重复的数字","date":"2021-08-31T06:27:11.000Z","updated":"2021-08-31T06:39:16.939Z","comments":true,"path":"2021/08/31/剑指Offer03-数组中重复的数字/","link":"","permalink":"https://tony2ty.github.io/2021/08/31/%E5%89%91%E6%8C%87Offer03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"剑指 Offer 03. 数组中重复的数字难度：简单 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 通过次数376,115 提交次数554,250 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(n)$ int findRepeatNumber(int* nums, int numsSize){ int array[100001] = {0}; for (int i = 0; i &lt; numsSize; i++) { array[nums[i]]++; } for (int i = 0; i &lt; 100001; i++) { if (array[i] >= 2) { return i; } } return 0; } 改进型 int findRepeatNumber(int* nums, int numsSize){ int array[100001] = {0}; for (int i = 0; i &lt; numsSize; i++) { array[nums[i]]++; if (array[nums[i]] >= 2) { return nums[i]; } } return 0; } 另一种解法 性能分析 时间复杂度：$O(nlogn)$​​​​ 空间复杂度：$O(n)$ int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int findRepeatNumber(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), cmpfunc); for (int i = 1; i &lt; numsSize; i++) { if (nums[i] == nums[i - 1]) { return nums[i]; } } return 0; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"快速排序","slug":"快速排序","permalink":"https://tony2ty.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"最大连续1的个数","slug":"最大连续1的个数","date":"2021-08-31T06:10:45.000Z","updated":"2021-08-31T06:28:59.566Z","comments":true,"path":"2021/08/31/最大连续1的个数/","link":"","permalink":"https://tony2ty.github.io/2021/08/31/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"","text":"485. 最大连续 1 的个数难度：简单 给定一个二进制数组， 计算其中最大连续 1 的个数。 示例： 输入：[1,1,0,1,1,1] 输出：3 解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3. 提示： 输入的数组只包含 0 和 1 。 输入数组的长度是正整数，且不超过 10,000。 通过次数118,530 提交次数195,441 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int findMaxConsecutiveOnes(int* nums, int numsSize){ int max = 0, tmp = 0; for (int i = 0; i &lt; numsSize; i++) { if (nums[i] == 0) { if (tmp > max) { max = tmp; } tmp = 0; } else { tmp++; } } if (tmp > max) { max = tmp; } return max; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"判断能否形成等差数列","slug":"判断能否形成等差数列","date":"2021-08-30T01:28:49.000Z","updated":"2021-08-30T01:32:06.250Z","comments":true,"path":"2021/08/30/判断能否形成等差数列/","link":"","permalink":"https://tony2ty.github.io/2021/08/30/%E5%88%A4%E6%96%AD%E8%83%BD%E5%90%A6%E5%BD%A2%E6%88%90%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/","excerpt":"","text":"1502. 判断能否形成等差数列难度：简单 给你一个数字数组 arr 。 如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。 如果可以重新排列数组形成等差数列，请返回 true ；否则，返回 false 。 示例 1： 输入：arr = [3,5,1] 输出：true 解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。 示例 2： 输入：arr = [1,2,4] 输出：false 解释：无法通过重新排序得到等差数列。 提示： 2 &lt;= arr.length &lt;= 1000 -10^6 &lt;= arr[i] &lt;= 10^6 通过次数24,728 提交次数34,463 性能分析 时间复杂度：$O(nlogn)$​​​​ 空间复杂度：$O(1)$ int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } bool canMakeArithmeticProgression(int* arr, int arrSize){ qsort(arr, arrSize, sizeof(int), cmpfunc); int diff = arr[1] - arr[0]; for (int i = 2; i &lt; arrSize; i++) { if (arr[i] - arr[i - 1] != diff) { return false; } } return true; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"快速排序","slug":"快速排序","permalink":"https://tony2ty.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"按奇偶排序数组II","slug":"按奇偶排序数组II","date":"2021-08-30T01:12:04.000Z","updated":"2021-08-30T01:17:13.219Z","comments":true,"path":"2021/08/30/按奇偶排序数组II/","link":"","permalink":"https://tony2ty.github.io/2021/08/30/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/","excerpt":"","text":"922. 按奇偶排序数组 II难度：简单 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 示例： 输入：[4,2,5,7] 输出：[4,5,2,7] 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示： 2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 通过次数88,813 提交次数124,334 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(n)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* sortArrayByParityII(int* nums, int numsSize, int* returnSize){ int array[10000] = {0}; int array2[10000] = {0}; int cnt = 0, cnt2 = 0; for (int i = 0; i &lt; numsSize; i++) { if (nums[i] % 2 == 0) { array[cnt++] = nums[i]; } else if (nums[i] % 2 == 1) { array2[cnt2++] = nums[i]; } } *returnSize = 0; int j = 0, k = 0; for (int i = 0; i &lt; numsSize; i++) { if (i % 2 == 0) { nums[(*returnSize)++] = array[j++]; } else { nums[(*returnSize)++] = array2[k++]; } } return nums; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指OfferII070.排序数组中只出现一次的数字","slug":"剑指OfferII070-排序数组中只出现一次的数字","date":"2021-08-29T00:08:04.000Z","updated":"2021-08-29T00:16:32.278Z","comments":true,"path":"2021/08/29/剑指OfferII070-排序数组中只出现一次的数字/","link":"","permalink":"https://tony2ty.github.io/2021/08/29/%E5%89%91%E6%8C%87OfferII070-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"剑指 Offer II 070. 排序数组中只出现一次的数字难度：中等 给定一个只包含整数的有序数组 nums ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。 示例 1: 输入: nums = [1,1,2,3,3,4,4,8,8] 输出: 2 示例 2: 输入: nums = [3,3,7,7,10,11,11] 输出: 10 提示: 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 105 进阶: 采用的方案可以在 O(log n) 时间复杂度和 O(1) 空间复杂度中运行吗？ 注意：本题与主站 540 题相同：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/ 通过次数754 提交次数1,083 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int singleNonDuplicate(int* nums, int numsSize){ int val = 0; for (int i = 0; i &lt; numsSize; i++) { val ^= nums[i]; } return val; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"异或法","slug":"异或法","permalink":"https://tony2ty.github.io/tags/%E5%BC%82%E6%88%96%E6%B3%95/"}]},{"title":"按奇偶排序数组","slug":"按奇偶排序数组","date":"2021-08-28T23:56:39.000Z","updated":"2021-08-28T23:59:24.878Z","comments":true,"path":"2021/08/29/按奇偶排序数组/","link":"","permalink":"https://tony2ty.github.io/2021/08/29/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"905. 按奇偶排序数组难度：简单 给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。 你可以返回满足此条件的任何数组作为答案。 示例： 输入：[3,1,2,4] 输出：[2,4,3,1] 输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。 提示： 1 &lt;= A.length &lt;= 5000 0 &lt;= A[i] &lt;= 5000 通过次数56,528 提交次数80,582 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(n)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* sortArrayByParity(int* nums, int numsSize, int* returnSize){ int array[5001] = {0}; for (int i = 0; i &lt; numsSize; i++) { array[nums[i]]++; } *returnSize = 0; for (int i = 0; i &lt; 5001; i+=2) { for(int j = 0; j &lt; array[i]; j++) { nums[(*returnSize)++] = i; } } for (int i = 1; i &lt; 5001; i+=2) { for(int j = 0; j &lt; array[i]; j++) { nums[(*returnSize)++] = i; } } return nums; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"}]},{"title":"找出数组的最大公约数","slug":"找出数组的最大公约数","date":"2021-08-28T12:48:24.000Z","updated":"2021-08-28T13:03:28.822Z","comments":true,"path":"2021/08/28/找出数组的最大公约数/","link":"","permalink":"https://tony2ty.github.io/2021/08/28/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/","excerpt":"","text":"1979. 找出数组的最大公约数难度：简单 给你一个整数数组 nums ，返回数组中最大数和最小数的 最大公约数 。 两个数的 最大公约数 是能够被两个数整除的最大正整数。 示例 1： 输入：nums = [2,5,6,9,10] 输出：2 解释： nums 中最小的数是 2 nums 中最大的数是 10 2 和 10 的最大公约数是 2 示例 2： 输入：nums = [7,5,6,8,3] 输出：1 解释： nums 中最小的数是 3 nums 中最大的数是 8 3 和 8 的最大公约数是 1 示例 3： 输入：nums = [3,3] 输出：3 解释： nums 中最小的数是 3 nums 中最大的数是 3 3 和 3 的最大公约数是 3 提示： 2 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 1000 通过次数5,571 提交次数6,670 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int findGCD(int* nums, int numsSize){ int max, min, val; max = min = nums[0]; for (int i = 1; i &lt; numsSize; i++) { if (nums[i] > max) { max = nums[i]; } if (nums[i] &lt; min) { min = nums[i]; } } for (int i = min; i > 0; i--) { if ((min % i == 0) &amp;&amp; (max % i == 0)) { return i; } } return 1; } 完善做法 int findGCD(int* nums, int numsSize){ int max, min, val; max = min = nums[0]; for (int i = 1; i &lt; numsSize; i++) { if (nums[i] > max) { max = nums[i]; } else if (nums[i] &lt; min) { min = nums[i]; } } for (int i = min; i > 0; i--) { if ((min % i == 0) &amp;&amp; (max % i == 0)) { return i; } } return 1; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"基于排列构建数组","slug":"基于排列构建数组","date":"2021-08-27T06:31:54.000Z","updated":"2021-08-27T06:43:00.676Z","comments":true,"path":"2021/08/27/基于排列构建数组/","link":"","permalink":"https://tony2ty.github.io/2021/08/27/%E5%9F%BA%E4%BA%8E%E6%8E%92%E5%88%97%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/","excerpt":"","text":"1920. 基于排列构建数组难度：简单 给你一个 从 0 开始的排列 nums（下标也从 0 开始）。请你构建一个 同样长度 的数组 ans ，其中，对于每个 i（0 &lt;= i &lt; nums.length），都满足 ans[i] = nums[nums[i]] 。返回构建好的数组 ans 。 从 0 开始的排列 nums 是一个由 0 到 nums.length - 1（0 和 nums.length - 1 也包含在内）的不同整数组成的数组。 示例 1： 输入：nums = [0,2,1,5,3,4] 输出：[0,1,2,4,5,3] 解释：数组 ans 构建如下： ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]] = [0,1,2,4,5,3] 示例 2： 输入：nums = [5,0,1,2,3,4] 输出：[4,5,0,1,2,3] 解释：数组 ans 构建如下： ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]] = [4,5,0,1,2,3] 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt; nums.length nums 中的元素 互不相同 通过次数8,208 提交次数8,731 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(n)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* buildArray(int* nums, int numsSize, int* returnSize){ *returnSize = numsSize; int *array = malloc(sizeof(int) * numsSize); for (int i = 0; i &lt; numsSize; i++) { array[i] = nums[nums[i]]; } return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"gdbserver远程调试","slug":"gdbserver远程调试","date":"2021-08-26T01:28:30.000Z","updated":"2021-08-26T02:01:13.452Z","comments":true,"path":"2021/08/26/gdbserver远程调试/","link":"","permalink":"https://tony2ty.github.io/2021/08/26/gdbserver%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/","excerpt":"","text":"gdb与gdbserver与远程调试应用程序开发环境软件：vmware+ubuntu 硬件：imx6ull开发板 准备工作 开发板需要支持gdbserver命令才行 ubuntu系统的IP地址为192.168.123.115。开发板的IP地址为192.168.123.117。 测试应用程序/* * @Description: * @Version: 2.0 * @Autor: wuying * @Date: 2021-03-22 14:24:02 * @LastEditors: wuying * @LastEditTime: 2021-08-25 09:44:50 */ #include &lt;signal.h> #include &lt;semaphore.h> #include &lt;sys/time.h> #include &lt;stdlib.h> #include &lt;stdbool.h> #include &lt;fcntl.h> #include &lt;stdint.h> #include &lt;stdio.h> #include &lt;unistd.h> #include &lt;stdlib.h> int main(int argc, char *argv[]) { while (1) { printf(\"hello world\\n\"); sleep(1); } return 0; } 编译应用程序，注意编译选项中加入-g。生成的可执行文件为hello。 将可执行文件hello拷贝到开发板。 调试在开发板上执行命令 gdbserver 192.168.123.117:6666 ./hello 在ubuntu系统命令行执行命令arm-linux-gnueabihf-gdb ./hello。在gdb命令下输入命令 target remote 192.168.123.117:6666，该ip地址与端口号即开发板上gdbserver的ip与端口号。 常用命令l命令l命令 (list)用于列出所有程序源码，输入“ l”，结果如下图 b命令b命令 (break)用于设置断点，后面可以跟具体的函数或者行号，比如break main”表示在 main函数处设置断点，“ break 11”在第 11行设置断点。输入如下命令，在 25行处设置断点： c命令c命令用于运行到断点出，输入 c命令程序就会运行，直到下一个断点处。 此时开发板上已经能看到响应信息输出 s命令s命令 (step)是单步运行执行，会进入到函数里面。 n命令n命令 (next)也是单步运行，但是 n命令不会进入到函数里面。 p命令p命令 (print)用于打印某个变量值。 q命令q命令 (quit)用于退出调试，开发板上的 gdbserver也会停止。","categories":[{"name":"嵌入式Linux","slug":"嵌入式Linux","permalink":"https://tony2ty.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"}],"tags":[{"name":"gdb调试","slug":"gdb调试","permalink":"https://tony2ty.github.io/tags/gdb%E8%B0%83%E8%AF%95/"}]},{"title":"去掉最低工资和最高工资后的工资平均值","slug":"去掉最低工资和最高工资后的工资平均值","date":"2021-08-26T01:11:54.000Z","updated":"2021-08-26T01:14:09.257Z","comments":true,"path":"2021/08/26/去掉最低工资和最高工资后的工资平均值/","link":"","permalink":"https://tony2ty.github.io/2021/08/26/%E5%8E%BB%E6%8E%89%E6%9C%80%E4%BD%8E%E5%B7%A5%E8%B5%84%E5%92%8C%E6%9C%80%E9%AB%98%E5%B7%A5%E8%B5%84%E5%90%8E%E7%9A%84%E5%B7%A5%E8%B5%84%E5%B9%B3%E5%9D%87%E5%80%BC/","excerpt":"","text":"1491. 去掉最低工资和最高工资后的工资平均值难度：简单 给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。 请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。 示例 1： 输入：salary = [4000,3000,1000,2000] 输出：2500.00000 解释：最低工资和最高工资分别是 1000 和 4000 。 去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500 示例 2： 输入：salary = [1000,2000,3000] 输出：2000.00000 解释：最低工资和最高工资分别是 1000 和 3000 。 去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000 示例 3： 输入：salary = [6000,5000,4000,3000,2000,1000] 输出：3500.00000 示例 4： 输入：salary = [8000,9000,2000,3000,6000,1000] 输出：4750.00000 提示： 3 &lt;= salary.length &lt;= 100 10^3 &lt;= salary[i] &lt;= 10^6 salary[i] 是唯一的。 与真实值误差在 10^-5 以内的结果都将视为正确答案。 通过次数19,362 提交次数28,848 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ double average(int* salary, int salarySize){ int max, min, sum = 0; double ret; max = min = salary[0]; sum = salary[0]; for (int i = 1; i &lt; salarySize; i++) { if (max &lt; salary[i]) { max = salary[i]; } if (min > salary[i]) { min = salary[i]; } sum += salary[i]; } sum -= max; sum -= min; // printf(\"%d %d %d\\n\", sum, max, min); ret = (double)sum / (salarySize - 2); return ret; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"好数对的数目","slug":"好数对的数目","date":"2021-08-26T00:54:58.000Z","updated":"2021-08-26T00:57:19.836Z","comments":true,"path":"2021/08/26/好数对的数目/","link":"","permalink":"https://tony2ty.github.io/2021/08/26/%E5%A5%BD%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/","excerpt":"","text":"1512. 好数对的数目难度：简单 给你一个整数数组 nums 。 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。 返回好数对的数目。 示例 1： 输入：nums = [1,2,3,1,1,3] 输出：4 解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始 示例 2： 输入：nums = [1,1,1,1] 输出：6 解释：数组中的每组数字都是好数对 示例 3： 输入：nums = [1,2,3] 输出：0 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 通过次数57,499 提交次数67,763 性能分析 时间复杂度：$O(n^2)$​​​​ 空间复杂度：$O(1)$ int numIdenticalPairs(int* nums, int numsSize){ int cnt = 0; for (int i = 0; i &lt; numsSize; i++) { for (int j = i+1; j&lt; numsSize; j++) { if (nums[i] == nums[j]) { cnt++; } } } return cnt; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"枚举法","slug":"枚举法","permalink":"https://tony2ty.github.io/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"}]},{"title":"找到所有数组中消失的数字","slug":"找到所有数组中消失的数字","date":"2021-08-25T01:10:25.000Z","updated":"2021-08-26T01:14:31.258Z","comments":true,"path":"2021/08/25/找到所有数组中消失的数字/","link":"","permalink":"https://tony2ty.github.io/2021/08/25/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"448. 找到所有数组中消失的数字难度：简单 给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。 示例 1： 输入：nums = [4,3,2,7,8,2,3,1] 输出：[5,6] 示例 2： 输入：nums = [1,1] 输出：[2] 提示： n == nums.length 1 &lt;= n &lt;= 105 1 &lt;= nums[i] &lt;= n 进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。 通过次数130,209 提交次数201,191 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){ *returnSize = 0; int *array = malloc(sizeof(int) * (numsSize + 1)); memset(array, 0x00, sizeof(int) * (numsSize + 1)); for (int i = 0; i &lt; numsSize; i++) { array[nums[i]]++; } for (int i = 1; i &lt; numsSize+1; i++) { if (array[i] == 0) { nums[(*returnSize)++] = i; } } return nums; } 第一次提交代码，未测试示例2的case。 int cmp_int(const void* _a , const void* _b) { int* a = (int*)_a; //强制类型转换 int* b = (int*)_b; return *a - *b; } /** * Note: The returned array must be malloced, assume caller calls free(). */ int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){ qsort(nums, numsSize, sizeof(nums[0]), cmp_int); *returnSize = 0; int *array = malloc(sizeof(int) * numsSize); for (int i = 1; i &lt; numsSize; i++) { if ((nums[i] - nums[i - 1]) > 1) { for (int j = 0; j &lt; nums[i] - nums[i - 1] - 1; j++) { array[(*returnSize)] = nums[i - 1] + j + 1; (*returnSize)++; } } } return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"}]},{"title":"最少操作使数组递增","slug":"最少操作使数组递增","date":"2021-08-24T00:56:42.000Z","updated":"2021-08-24T00:59:23.940Z","comments":true,"path":"2021/08/24/最少操作使数组递增/","link":"","permalink":"https://tony2ty.github.io/2021/08/24/%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E4%BD%BF%E6%95%B0%E7%BB%84%E9%80%92%E5%A2%9E/","excerpt":"","text":"1827. 最少操作使数组递增难度：简单 给你一个整数数组 nums （下标从 0 开始）。每一次操作中，你可以选择数组中一个元素，并将它增加 1 。 比方说，如果 nums = [1,2,3] ，你可以选择增加 nums[1] 得到 nums = [1,**3**,3] 。 请你返回使 nums 严格递增 的 最少 操作次数。 我们称数组 nums 是 严格递增的 ，当它满足对于所有的 0 &lt;= i &lt; nums.length - 1 都有 nums[i] &lt; nums[i+1] 。一个长度为 1 的数组是严格递增的一种特殊情况。 示例 1： 输入：nums = [1,1,1] 输出：3 解释：你可以进行如下操作： 1) 增加 nums[2] ，数组变为 [1,1,2] 。 2) 增加 nums[1] ，数组变为 [1,2,2] 。 3) 增加 nums[2] ，数组变为 [1,2,3] 。 示例 2： 输入：nums = [1,5,2,4,1] 输出：14 示例 3： 输入：nums = [8] 输出：0 提示： 1 &lt;= nums.length &lt;= 5000 1 &lt;= nums[i] &lt;= 104 通过次数8,677 提交次数10,899 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int minOperations(int* nums, int numsSize){ if (numsSize == 1) { return 0; } int cnt = 0, diff = 0; for (int i = 0; i &lt; numsSize - 1; i++) { if (nums[i+1] &lt;= nums[i]) { diff = nums[i] - nums[i+1]; nums[i+1] += diff + 1; cnt += diff + 1; } } return cnt; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"存在重复元素II","slug":"存在重复元素II","date":"2021-08-23T01:30:27.000Z","updated":"2021-08-23T01:37:13.369Z","comments":true,"path":"2021/08/23/存在重复元素II/","link":"","permalink":"https://tony2ty.github.io/2021/08/23/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/","excerpt":"","text":"219. 存在重复元素 II难度：简单 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 **nums [i] = nums [j]**，并且 i 和 j 的差的 绝对值 至多为 k。 示例 1: 输入: nums = [1,2,3,1], k = 3 输出: true 示例 2: 输入: nums = [1,0,1,1], k = 1 输出: true 示例 3: 输入: nums = [1,2,3,1,2,3], k = 2 输出: false 通过次数105,366 提交次数247,598 难度：中等 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(n)$ bool containsNearbyDuplicate(int* nums, int numsSize, int k){ int stack[numsSize]; int top = -1; for (int i = 0; i &lt; numsSize; i++) { while (top > -1 &amp;&amp; nums[i] &lt; nums[stack[top]]) { top--; } if (top > -1 &amp;&amp; nums[i] == nums[stack[top]]) { if (abs(stack[top] - i) &lt;= k) { return true; } } stack[++top] = i; // printf(\"%d %d %d %d\\n\", i, top, nums[i], stack[top]); } return false; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"单调栈","slug":"单调栈","permalink":"https://tony2ty.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"剑指Offer21.调整数组顺序使奇数位于偶数前面","slug":"剑指Offer21-调整数组顺序使奇数位于偶数前面","date":"2021-08-21T22:54:25.000Z","updated":"2021-08-29T00:16:20.847Z","comments":true,"path":"2021/08/22/剑指Offer21-调整数组顺序使奇数位于偶数前面/","link":"","permalink":"https://tony2ty.github.io/2021/08/22/%E5%89%91%E6%8C%87Offer21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/","excerpt":"","text":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面难度：简单 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例： 输入：nums = [1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示： 0 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10000 通过次数175,932 提交次数273,840 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(n)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* exchange(int* nums, int numsSize, int* returnSize){ int i, j, k, cnt1 = 0, cnt2 = 0; for (i = 0; i &lt; numsSize; i++) { if (nums[i] % 2 == 0) { cnt1++; } else { cnt2++; } } int *array1 = malloc(sizeof(int) * cnt1); int *array2 = malloc(sizeof(int) * cnt2); for (i = 0, j = 0, k = 0; i &lt; numsSize; i++) { if (nums[i] % 2 == 0) { array1[j++] = nums[i]; nums[i] = 0; } else { array2[k++] = nums[i]; nums[i] = 0; } } for(j = 0; j &lt; cnt2; j++) { nums[j] = array2[j]; } for(i = 0; i&lt; cnt1; i++) { nums[i + cnt2] = array1[i]; } free(array1); free(array2); *returnSize = numsSize; return nums; } 另一种解法 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(n)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* exchange(int* nums, int numsSize, int* returnSize){ int array[10001] = {0}; for (int i = 0; i &lt; numsSize; i++) { array[nums[i]]++; } *returnSize = 0; for (int i = 1; i &lt; 10001; i+=2) { for(int j = 0; j &lt; array[i]; j++) { nums[(*returnSize)++] = i; } } for (int i = 0; i &lt; 10001; i+=2) { for(int j = 0; j &lt; array[i]; j++) { nums[(*returnSize)++] = i; } } return nums; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"剑指OfferII006.排序数组中两个数字之和","slug":"剑指OfferII006-排序数组中两个数字之和","date":"2021-08-21T06:20:07.000Z","updated":"2021-08-21T06:24:25.197Z","comments":true,"path":"2021/08/21/剑指OfferII006-排序数组中两个数字之和/","link":"","permalink":"https://tony2ty.github.io/2021/08/21/%E5%89%91%E6%8C%87OfferII006-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/","excerpt":"","text":"剑指 Offer II 006. 排序数组中两个数字之和难度：简单 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 0 开始计数 ，所以答案数组应当满足 0 &lt;= answer[0] &lt; answer[1] &lt; numbers.length 。 假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。 示例 1： 输入：numbers = [1,2,4,6,10], target = 8 输出：[1,3] 解释：2 与 6 之和等于目标数 8 。因此 index1 = 1, index2 = 3 。 示例 2： 输入：numbers = [2,3,4], target = 6 输出：[0,2] 示例 3： 输入：numbers = [-1,0], target = -1 输出：[0,1] 提示： 2 &lt;= numbers.length &lt;= 3 * 104 -1000 &lt;= numbers[i] &lt;= 1000 numbers 按 递增顺序 排列 -1000 &lt;= target &lt;= 1000 仅存在一个有效答案 注意：本题与主站 167 题相似（下标起点不同）：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){ int i, j, val; int *array = malloc(sizeof(int) * 2); for (i = 0, j = numbersSize - 1; i &lt; j;) { // printf(\"%d %d\\n\", i, j); val = numbers[i] + numbers[j]; if (val > target) { j--; } else if (val &lt; target) { i++; } else { array[0] = i; array[1] = j; break; } } *returnSize = 2; return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针法","slug":"双指针法","permalink":"https://tony2ty.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"剑指OfferII038.每日温度","slug":"剑指OfferII038-每日温度","date":"2021-08-20T01:35:19.000Z","updated":"2021-08-20T01:37:27.864Z","comments":true,"path":"2021/08/20/剑指OfferII038-每日温度/","link":"","permalink":"https://tony2ty.github.io/2021/08/20/%E5%89%91%E6%8C%87OfferII038-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/","excerpt":"","text":"剑指 Offer II 038. 每日温度难度：中等 请根据每日 气温 列表 temperatures ，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 示例 1: 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0] 示例 2: 输入: temperatures = [30,40,50,60] 输出: [1,1,1,0] 示例 3: 输入: temperatures = [30,60,90] 输出: [1,1,0] 提示： 1 &lt;= temperatures.length &lt;= 105 30 &lt;= temperatures[i] &lt;= 100 注意：本题与主站 739 题相同： https://leetcode-cn.com/problems/daily-temperatures/ 通过次数629 提交次数805 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(n)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize){ int *stack = malloc(sizeof(int) * temperaturesSize); int top = -1; // int *temper = malloc(sizeof(int) * temperaturesSize); memset(stack, 0x00, sizeof(int) * temperaturesSize); // memset(temper, 0x00, sizeof(int) * temperaturesSize); for (int i = 0; i &lt; temperaturesSize; i++) { // printf(\"a %d %d\\n\", top, i); while (top >= 0 &amp;&amp; temperatures[i] > temperatures[stack[top]]) { // printf(\"b %d %d %d\\n\", temperatures[i], temperatures[stack[top]], stack[top]); temperatures[stack[top]] = i - stack[top]; top--; } stack[++top] = i; } while (top >= 0) { temperatures[stack[top]] = 0; top--; } *returnSize = temperaturesSize; free(stack); return temperatures; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"单调栈","slug":"单调栈","permalink":"https://tony2ty.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"唯一元素的和","slug":"唯一元素的和","date":"2021-08-20T00:50:24.000Z","updated":"2021-08-20T00:52:42.593Z","comments":true,"path":"2021/08/20/唯一元素的和/","link":"","permalink":"https://tony2ty.github.io/2021/08/20/%E5%94%AF%E4%B8%80%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/","excerpt":"","text":"1748. 唯一元素的和难度：简单 给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。 请你返回 nums 中唯一元素的 和 。 示例 1： 输入：nums = [1,2,3,2] 输出：4 解释：唯一元素为 [1,3] ，和为 4 。 示例 2： 输入：nums = [1,1,1,1,1] 输出：0 解释：没有唯一元素，和为 0 。 示例 3 ： 输入：nums = [1,2,3,4,5] 输出：15 解释：唯一元素为 [1,2,3,4,5] ，和为 15 。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 通过次数10,211 提交次数13,621 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int sumOfUnique(int* nums, int numsSize){ int array[100 + 1] = {0}; for (int i = 0; i &lt; numsSize; i++) { array[nums[i]]++; } int sum = 0; for (int i = 0; i &lt; 101; i++) { if (array[i] == 1) { sum += i; } } return sum; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"}]},{"title":"解码异或后的数组","slug":"解码异或后的数组","date":"2021-08-19T02:01:20.000Z","updated":"2021-08-19T02:02:49.132Z","comments":true,"path":"2021/08/19/解码异或后的数组/","link":"","permalink":"https://tony2ty.github.io/2021/08/19/%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/","excerpt":"","text":"1720. 解码异或后的数组难度：简单 未知 整数数组 arr 由 n 个非负整数组成。 经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。 给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。 请解码返回原数组 arr 。可以证明答案存在并且是唯一的。 示例 1： 输入：encoded = [1,2,3], first = 1 输出：[1,0,2,1] 解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3] 示例 2： 输入：encoded = [6,2,7,3], first = 4 输出：[4,2,0,7,4] 提示： 2 &lt;= n &lt;= 104 encoded.length == n - 1 0 &lt;= encoded[i] &lt;= 105 0 &lt;= first &lt;= 105 通过次数45,674 提交次数52,539 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* decode(int* encoded, int encodedSize, int first, int* returnSize){ int *array = malloc(sizeof(int) * (encodedSize + 1)); array[0] = first; for (int i = 1; i &lt; encodedSize + 1; i++) { array[i] = array[i - 1] ^ encoded[i - 1]; } *returnSize = encodedSize + 1; return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"统计位数为偶数的数字","slug":"统计位数为偶数的数字","date":"2021-08-19T01:16:40.000Z","updated":"2021-08-19T01:17:56.010Z","comments":true,"path":"2021/08/19/统计位数为偶数的数字/","link":"","permalink":"https://tony2ty.github.io/2021/08/19/%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"1295. 统计位数为偶数的数字难度：简单 给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。 示例 1： 输入：nums = [12,345,2,6,7896] 输出：2 解释： 12 是 2 位数字（位数为偶数） 345 是 3 位数字（位数为奇数） 2 是 1 位数字（位数为奇数） 6 是 1 位数字 位数为奇数） 7896 是 4 位数字（位数为偶数） 因此只有 12 和 7896 是位数为偶数的数字 示例 2： 输入：nums = [555,901,482,1771] 输出：1 解释： 只有 1771 是位数为偶数的数字。 提示： 1 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 10^5 通过次数47,008 提交次数58,083 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$​ int findNumbers(int* nums, int numsSize){ int cnt = 0; for (int i = 0; i &lt; numsSize; i++) { if (nums[i] >= 10 &amp;&amp; nums[i] &lt;= 99) { cnt++; } else if (nums[i] >= 1000 &amp;&amp; nums[i] &lt;= 9999) { cnt++; } else if (nums[i] >= 100000 &amp;&amp; nums[i] &lt;= 999999) { cnt++; } } return cnt; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"数组中两元素的最大乘积","slug":"数组中两元素的最大乘积","date":"2021-08-18T01:28:21.000Z","updated":"2021-08-18T01:30:10.543Z","comments":true,"path":"2021/08/18/数组中两元素的最大乘积/","link":"","permalink":"https://tony2ty.github.io/2021/08/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/","excerpt":"","text":"1464. 数组中两元素的最大乘积难度：简单 给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。 请你计算并返回该式的最大值。 示例 1： 输入：nums = [3,4,5,2] 输出：12 解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 示例 2： 输入：nums = [1,5,4,5] 输出：16 解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。 示例 3： 输入：nums = [3,7] 输出：12 提示： 2 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 10^3 通过次数25,280 提交次数32,933 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$​ int maxProduct(int* nums, int numsSize){ int i, first = 0, second = 0; first = nums[0]; second = nums[1]; for (i = 1; i &lt; numsSize; i++) { if (nums[i] > first) { second = first; first = nums[i]; // printf(\"%d %d\\n\", first, second); } else if (nums[i] == first) { second = nums[i]; } else if (nums[i] &lt; first &amp;&amp; nums[i] > second) { second = nums[i]; } } return (first - 1) * (second - 1); }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"在既定时间做作业的学生人数","slug":"在既定时间做作业的学生人数","date":"2021-08-17T03:49:13.000Z","updated":"2021-08-17T03:56:03.899Z","comments":true,"path":"2021/08/17/在既定时间做作业的学生人数/","link":"","permalink":"https://tony2ty.github.io/2021/08/17/%E5%9C%A8%E6%97%A2%E5%AE%9A%E6%97%B6%E9%97%B4%E5%81%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B0/","excerpt":"","text":"1450. 在既定时间做作业的学生人数难度：简单 给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。 已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。 请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。 示例 1： 输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4 输出：1 解释：一共有 3 名学生。 第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。 第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。 第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。 示例 2： 输入：startTime = [4], endTime = [4], queryTime = 4 输出：1 解释：在查询时间只有一名学生在做作业。 示例 3： 输入：startTime = [4], endTime = [4], queryTime = 5 输出：0 示例 4： 输入：startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7 输出：0 示例 5： 输入：startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5 输出：5 提示： startTime.length == endTime.length 1 &lt;= startTime.length &lt;= 100 1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000 1 &lt;= queryTime &lt;= 1000 通过次数23,528 提交次数29,332 性能分析 时间复杂度：$O(n)$​​​​ 空间复杂度：$O(1)$ int busyStudent(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int queryTime){ int cnt = 0; for (int i = 0; i &lt; startTimeSize; i++) { if(startTime[i] &lt;= queryTime &amp;&amp; endTime[i] >= queryTime) { cnt++; } } return cnt; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"商品折扣后的最终价格","slug":"商品折扣后的最终价格","date":"2021-08-16T01:44:04.000Z","updated":"2021-08-17T04:19:00.735Z","comments":true,"path":"2021/08/16/商品折扣后的最终价格/","link":"","permalink":"https://tony2ty.github.io/2021/08/16/%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/","excerpt":"","text":"1475. 商品折扣后的最终价格难度：简单 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。 请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。 示例 1： 输入：prices = [8,4,6,2,3] 输出：[4,2,4,2,3] 解释： 商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。 商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。 商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。 商品 3 和 4 都没有折扣。 示例 2： 输入：prices = [1,2,3,4,5] 输出：[1,2,3,4,5] 解释：在这个例子中，所有商品都没有折扣。 示例 3： 输入：prices = [10,1,1,6] 输出：[9,0,1,6] 提示： 1 &lt;= prices.length &lt;= 500 1 &lt;= prices[i] &lt;= 10^3 通过次数13,534 提交次数18,695 性能分析 时间复杂度：$O(n^2)$​​​ 空间复杂度：$O(n)$​​ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* finalPrices(int* prices, int pricesSize, int* returnSize){ int *array = malloc(sizeof(int) * pricesSize); for(int i = 0; i &lt; pricesSize; i++) { array[i] = prices[i]; for (int j = i + 1; j &lt; pricesSize; j++) { // printf(\"%d %d\\n\", prices[i], prices[j]); if (prices[j] &lt;= prices[i]) { array[i] = prices[i] - prices[j]; break; } } } *returnSize = pricesSize; return array; } 时间复杂度：$O(n^2)$​​​​ 空间复杂度：$O(1)$​ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* finalPrices(int* prices, int pricesSize, int* returnSize){ //int *array = malloc(sizeof(int) * pricesSize); for(int i = 0; i &lt; pricesSize; i++) { // array[i] = prices[i]; for (int j = i + 1; j &lt; pricesSize; j++) { // printf(\"%d %d\\n\", prices[i], prices[j]); if (prices[j] &lt;= prices[i]) { prices[i] = prices[i] - prices[j]; break; } } } *returnSize = pricesSize; return prices; } 时间复杂度：$O(n)$​​​​​ 空间复杂度：$O(n)$​​​ #define StackSize 500 typedef int DataType; typedef struct { DataType stack[StackSize]; int top; } SeqStack; /* 初始化栈 */ void InitStack(SeqStack *S) { S->top = 0; } /* 判断栈是否为空，栈为空返回1，否则返回0 */ int StackEmpty(SeqStack *S) { if (S->top == 0) { return 1; } return 0; } /* 取栈顶元素。将栈顶元素值返回给e，返回1表示成功，返回0表示失败。 */ DataType GetTop(SeqStack *S) { if (S->top == 0) { return 0; } return S->stack[S->top - 1]; } /* 将元素e进栈，元素进栈成功返回1，否则返回0. */ int PushStack(SeqStack *S, DataType e) { if (S->top >= StackSize) { return 0; } else { S->stack[S->top] = e; S->top++; } return 1; } /* 出栈操作。将栈顶元素出栈，并将其赋值给e。出栈成功返回1，否则返回0 */ int PopStack(SeqStack *S, DataType *e) { if (S->top == 0) { return 0; } S->top--; *e = S->stack[S->top]; return 1; } /* 求栈的长度 */ int StackLength(SeqStack *S) { return S->top; } /* 清空栈 */ void ClearStack(SeqStack *S) { S->top = 0; } /** * Note: The returned array must be malloced, assume caller calls free(). */ int* finalPrices(int* prices, int pricesSize, int* returnSize){ //int *array = malloc(sizeof(int) * pricesSize); SeqStack S; DataType temp; DataType top; InitStack(&amp;S); for(int i = 0; i &lt; pricesSize; i++) { // printf(\"bbbb %d %d %d\\n\", StackLength(&amp;S), prices[i], prices[GetTop(&amp;S)]); while (!StackEmpty(&amp;S) &amp;&amp; (prices[i] &lt;= prices[GetTop(&amp;S)])) { // printf(\"%d %d %d %d\\n\", GetTop(&amp;S), i, prices[GetTop(&amp;S)], prices[i]); prices[GetTop(&amp;S)] -= prices[i]; PopStack(&amp;S, &amp;temp); // printf(\"aaaa %d\\n\", StackLength(&amp;S)); } PushStack(&amp;S, i); // printf(\"%d\\n\", StackLength(&amp;S)); } *returnSize = pricesSize; return prices; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"每日温度","slug":"每日温度","date":"2021-08-13T02:22:29.000Z","updated":"2021-08-13T02:29:49.383Z","comments":true,"path":"2021/08/13/每日温度/","link":"","permalink":"https://tony2ty.github.io/2021/08/13/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/","excerpt":"","text":"739. 每日温度难度：中等 请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。 示例 1: 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0] 示例 2: 输入: temperatures = [30,40,50,60] 输出: [1,1,1,0] 示例 3: 输入: temperatures = [30,60,90] 输出: [1,1,0] 提示： 1 &lt;= temperatures.length &lt;= 105 30 &lt;= temperatures[i] &lt;= 100 通过次数192,968 提交次数285,087 解题思路 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* dailyTemperatures(int* temperatures, int temperaturesSize, int* returnSize){ int *array = malloc(sizeof(int) * temperaturesSize); memset(array, 0x00, sizeof(int) * temperaturesSize); int stack[temperaturesSize]; int top = -1; for (int i = 0; i &lt; temperaturesSize; i++) { if (top > -1 &amp;&amp; temperatures[i] > temperatures[stack[top]]) { while(top > -1 &amp;&amp; temperatures[i] > temperatures[stack[top]]) { array[stack[top]] = i - stack[top]; top--; } } stack[++top] = i; } *returnSize = temperaturesSize; return array; } 性能分析 单调栈法 时间复杂度：$O(n)$​​ 空间复杂度：$O(n)$ 枚举法会超时。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"单调栈","slug":"单调栈","permalink":"https://tony2ty.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"所有奇数长度子数组的和","slug":"所有奇数长度子数组的和","date":"2021-08-13T01:09:03.000Z","updated":"2021-08-13T01:14:25.069Z","comments":true,"path":"2021/08/13/所有奇数长度子数组的和/","link":"","permalink":"https://tony2ty.github.io/2021/08/13/%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/","excerpt":"","text":"1588. 所有奇数长度子数组的和难度：简单 给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 请你返回 arr 中 所有奇数长度子数组的和 。 示例 1： 输入：arr = [1,4,2,5,3] 输出：58 解释：所有奇数长度子数组和它们的和为： [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 示例 2： 输入：arr = [1,2] 输出：3 解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。 示例 3： 输入：arr = [10,11,12] 输出：66 提示： 1 &lt;= arr.length &lt;= 100 1 &lt;= arr[i] &lt;= 1000 通过次数20,439 提交次数25,489 性能分析 时间复杂度：$O(n^3)$​ 空间复杂度：$O(1)$ int sumOddLengthSubarrays(int* arr, int arrSize){ int cnt = 0; for (int i = 1; i &lt;= arrSize; i += 2) { for (int j = 0; j + i &lt;= arrSize; j++) { for (int k = j; k &lt; i + j; k++) { // printf(\"%d %d %d %d\\n\", i, j ,k, arr[k]); cnt += arr[k]; } } } return cnt; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"枚举法","slug":"枚举法","permalink":"https://tony2ty.github.io/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"}]},{"title":"石子游戏","slug":"石子游戏","date":"2021-08-12T00:16:53.000Z","updated":"2021-08-13T02:35:59.901Z","comments":true,"path":"2021/08/12/石子游戏/","link":"","permalink":"https://tony2ty.github.io/2021/08/12/%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","excerpt":"","text":"877. 石子游戏难度：中等 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例： 输入：[5,3,4,5] 输出：true 解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 提示： 2 &lt;= piles.length &lt;= 500 piles.length 是偶数。 1 &lt;= piles[i] &lt;= 500 sum(piles) 是奇数。 通过次数65,068 提交次数86,019 解题思路 重新申请一块同样大小的内存，根据题目的要求重新排列数组，新排列数组索引为偶数的是alex选择的石头；奇数是li选择的石头。重新统计后即可知道alex与li谁的多。 性能分析 时间复杂度：$O(n)$​​ 空间复杂度：$O(n)$​ bool stoneGame(int* piles, int pilesSize){ int alex = 0, li = 0; int i, j; int *array = malloc(sizeof(int) * pilesSize); int m = 0; for (i = 0, j = pilesSize - 1; i &lt; j; m++) { if (piles[i] > piles[j]) { array[m] = piles[i]; i++; } else { array[m] = piles[j]; j--; } } for (i = 0; i &lt; pilesSize / 2; i++) { alex += array[i * 2]; li += array[i * 2 + 1]; } if (alex > li) { return true; } return false; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"数组元素积的符号","slug":"数组元素积的符号","date":"2021-08-11T23:49:59.000Z","updated":"2021-08-13T02:35:59.893Z","comments":true,"path":"2021/08/12/数组元素积的符号/","link":"","permalink":"https://tony2ty.github.io/2021/08/12/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%A7%AF%E7%9A%84%E7%AC%A6%E5%8F%B7/","excerpt":"","text":"1822. 数组元素积的符号难度：简单 已知函数 signFunc(x) 将会根据 x 的正负返回特定值： 如果 x 是正数，返回 1 。 如果 x 是负数，返回 -1 。 如果 x 是等于 0 ，返回 0 。 给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。 返回 signFunc(product) 。 示例 1： 输入：nums = [-1,-2,-3,-4,3,2,1] 输出：1 解释：数组中所有值的乘积是 144 ，且 signFunc(144) = 1 示例 2： 输入：nums = [1,5,0,2,-3] 输出：0 解释：数组中所有值的乘积是 0 ，且 signFunc(0) = 0 示例 3： 输入：nums = [-1,1,-1,1,-1] 输出：-1 解释：数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1 提示： 1 &lt;= nums.length &lt;= 1000 -100 &lt;= nums[i] &lt;= 100 通过次数18,951 提交次数23,254 性能分析 时间复杂度：$O(n)$​ 空间复杂度：$O(1)$ int arraySign(int* nums, int numsSize){ int net_cnt = 0; for (int i = 0; i &lt; numsSize; i++) { if (nums[i] == 0) { return 0; } else if (nums[i] &lt; 0) { net_cnt++; } } if (net_cnt % 2 == 1) { return -1; } else { return 1; } return 0; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"数组中数字出现的次数II","slug":"数组中数字出现的次数II","date":"2021-08-11T03:10:42.000Z","updated":"2021-08-11T03:20:41.908Z","comments":true,"path":"2021/08/11/数组中数字出现的次数II/","link":"","permalink":"https://tony2ty.github.io/2021/08/11/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0II/","excerpt":"","text":"剑指 Offer 56 - II. 数组中数字出现的次数 II难度：中等 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 示例 1： 输入：nums = [3,4,3,3] 输出：4 示例 2： 输入：nums = [9,1,7,9,7,9,7] 输出：1 限制： 1 &lt;= nums.length &lt;= 10000 1 &lt;= nums[i] &lt; 2^31 性能分析 时间复杂度：$O(nlogn)$ 空间复杂度：$O(1)$ int cmp_int(const void* _a , const void* _b) { int* a = (int*)_a; int* b = (int*)_b; return *a - *b; } int singleNumber(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(nums[0]), cmp_int); int ret = nums[0]; if (nums[0] != nums[1]) { // printf(\"aaaa\\n\"); return nums[0]; } else if (nums[numsSize - 1] != nums[numsSize - 2]) { // printf(\"bbbb\\n\"); return nums[numsSize - 1]; } for(int i = 3; i &lt; numsSize; i+=3) { if ((nums[i] != nums[i - 1]) &amp;&amp; (nums[i] != nums[i + 1])) { // printf(\"cccc\\n\"); return nums[i]; } } return 0; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"快速排序","slug":"快速排序","permalink":"https://tony2ty.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"解压缩编码列表","slug":"解压缩编码列表","date":"2021-08-11T00:58:52.000Z","updated":"2021-08-11T01:01:48.674Z","comments":true,"path":"2021/08/11/解压缩编码列表/","link":"","permalink":"https://tony2ty.github.io/2021/08/11/%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8/","excerpt":"","text":"1313. 解压缩编码列表难度：简单 给你一个以行程长度编码压缩的整数列表 nums 。 考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]] （其中 i &gt;= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。 请你返回解压后的列表。 示例 1： 输入：nums = [1,2,3,4] 输出：[2,4,4,4] 解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。 第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。 最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。 示例 2： 输入：nums = [1,1,2,3] 输出：[1,3,3] 提示： 2 &lt;= nums.length &lt;= 100 nums.length % 2 == 0 1 &lt;= nums[i] &lt;= 100 通过次数34,302 提交次数41,300 性能分析 时间复杂度：$O(n^2)$​ 空间复杂度：$O(1)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* decompressRLElist(int* nums, int numsSize, int* returnSize){ int cnt = 0, index = 0; for (int i = 0; i &lt; numsSize; i+=2) { cnt += nums[i]; } int *array = malloc(sizeof(int) * cnt); for (int i = 0; i &lt; numsSize; i+=2) { for (int j = 0; j &lt; nums[i]; j++) { array[index + j] = nums[i+1]; } index += nums[i]; // printf(\"%d\\n\", index); } *returnSize = cnt; return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"数组串联","slug":"数组串联","date":"2021-08-10T00:47:33.000Z","updated":"2021-08-10T01:15:13.246Z","comments":true,"path":"2021/08/10/数组串联/","link":"","permalink":"https://tony2ty.github.io/2021/08/10/%E6%95%B0%E7%BB%84%E4%B8%B2%E8%81%94/","excerpt":"","text":"1929. 数组串联难度：简单 给你一个长度为 n 的整数数组 nums 。请你构建一个长度为 2n 的答案数组 ans ，数组下标 从 0 开始计数 ，对于所有 0 &lt;= i &lt; n 的 i ，满足下述所有要求： ans[i] == nums[i] ans[i + n] == nums[i] 具体而言，ans 由两个 nums 数组 串联 形成。 返回数组 ans 。 示例 1： 输入：nums = [1,2,1] 输出：[1,2,1,1,2,1] 解释：数组 ans 按下述方式形成： - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]] - ans = [1,2,1,1,2,1] 示例 2： 输入：nums = [1,3,2,1] 输出：[1,3,2,1,1,3,2,1] 解释：数组 ans 按下述方式形成： - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]] - ans = [1,3,2,1,1,3,2,1] 提示： n == nums.length 1 &lt;= n &lt;= 1000 1 &lt;= nums[i] &lt;= 1000 通过次数7,640 提交次数8,060 性能分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* getConcatenation(int* nums, int numsSize, int* returnSize){ int *array = malloc(sizeof(int) * numsSize * 2); for (int i = 0; i &lt; numsSize; i++) { array[i] = nums[i]; array[i + numsSize] = nums[i]; } *returnSize = numsSize * 2; return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"gcc动态库制作与使用","slug":"gcc动态库制作与使用","date":"2021-08-09T04:46:08.000Z","updated":"2021-08-09T05:33:05.625Z","comments":true,"path":"2021/08/09/gcc动态库制作与使用/","link":"","permalink":"https://tony2ty.github.io/2021/08/09/gcc%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"GCC动态库制作与使用演示工程说明 add.c sub.c mult.c div.c main.c 将add.c、sub.c、mult.c、div.c四个文件合并生成libmymath.so库。main.c内man函数调用四个文件内的相关函数。 制作步骤 将*.c文件生成*.o文件 gcc -c add.c -o add.o -fPIC gcc -c sub.c -o sub.o -fPIC gcc -c mult.c -o mult.o -fPIC gcc -c div.c -o div.o -fPIC 使用gcc -shared制作动态库 gcc -shared -o libmymath.so add.o sub.o mult.o div.o 编译可执行程序时，指定所使用的动态库名以及路径 gcc main.c -o a.out -lmymath -L ./lib 执行a.out文件 解决方法 增加自有库支持。通过下列命令，将库所在路径增加到文件的末尾。 sudo vim /etc/ld.so.conf 执行命令sudo ldconfig -v使配置文件生效。 使用命令ldd a.out查看 可以看到库libmymath.so已经有相对应的路径。再次执行./a.out。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://tony2ty.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"GCC","slug":"GCC","permalink":"https://tony2ty.github.io/categories/GCC/"}],"tags":[{"name":"动态库","slug":"动态库","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"}]},{"title":"数组中最大数对和的最小值","slug":"数组中最大数对和的最小值","date":"2021-08-08T23:59:00.000Z","updated":"2021-08-09T00:07:43.117Z","comments":true,"path":"2021/08/09/数组中最大数对和的最小值/","link":"","permalink":"https://tony2ty.github.io/2021/08/09/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","excerpt":"","text":"1877. 数组中最大数对和的最小值难度：中等 一个数对 (a,b) 的 数对和 等于 a + b 。最大数对和 是一个数对数组中最大的 数对和 。 比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。 给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得： nums 中每个元素 恰好 在 一个 数对中，且 最大数对和 的值 最小 。 请你在最优数对划分的方案下，返回最小的 最大数对和 。 示例 1： 输入：nums = [3,5,2,3] 输出：7 解释：数组中的元素可以分为数对 (3,3) 和 (5,2) 。 最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。 示例 2： 输入：nums = [3,5,4,2,4,6] 输出：8 解释：数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。 最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。 提示： n == nums.length 2 &lt;= n &lt;= 105 n 是 偶数 。 1 &lt;= nums[i] &lt;= 105 通过次数29,696 提交次数36,233 int comp(const void *a,const void *b) { return *(int*)a-*(int*)b; } int minPairSum(int* nums, int numsSize){ int max = 0; qsort(nums, numsSize, sizeof(nums[0]), comp); for (int i = 0; i &lt; numsSize / 2; i++) { if (nums[i] + nums[numsSize - 1 - i] > max) { max = nums[i] + nums[numsSize - 1 - i]; } } return max; } 性能分析 时间复杂度：$O(nlogn)$​​ 空间复杂度：$O(1)$","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"拿硬币","slug":"拿硬币","date":"2021-08-08T23:47:08.000Z","updated":"2021-08-09T00:08:11.554Z","comments":true,"path":"2021/08/09/拿硬币/","link":"","permalink":"https://tony2ty.github.io/2021/08/09/%E6%8B%BF%E7%A1%AC%E5%B8%81/","excerpt":"","text":"LCP 06. 拿硬币难度：简单 桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。 示例 1： 输入：[4,2,1] 输出：4 解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例 2： 输入：[2,3,10] 输出：8 限制： 1 &lt;= n &lt;= 4 1 &lt;= coins[i] &lt;= 10 通过次数41,733 提交次数49,779 int minCount(int* coins, int coinsSize){ int count = 0; for (int i = 0; i &lt; coinsSize; i++) { count += (coins[i] + 1) / 2; } return count; } 性能分析 时间复杂度：$O(n)$ 空间复杂度：$O(1)$","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"重新排列数组","slug":"重新排列数组","date":"2021-08-08T00:53:31.000Z","updated":"2021-08-08T01:06:18.476Z","comments":true,"path":"2021/08/08/重新排列数组/","link":"","permalink":"https://tony2ty.github.io/2021/08/08/%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/","excerpt":"","text":"1470. 重新排列数组难度：简单 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。 示例 1： 输入：nums = [2,5,1,3,4,7], n = 3 输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2： 输入：nums = [1,2,3,4,4,3,2,1], n = 4 输出：[1,4,2,3,3,2,4,1] 示例 3： 输入：nums = [1,1,2,2], n = 2 输出：[1,2,1,2] 提示： 1 &lt;= n &lt;= 500 nums.length == 2n 1 &lt;= nums[i] &lt;= 10^3 通过次数52,175 提交次数61,861 解题 时间复杂度：$O(N^2)$ 空间复杂度：$O(1)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* shuffle(int* nums, int numsSize, int n, int* returnSize){ int i, j, k, tmp; if (numsSize != 2 * n) { return NULL; } for (i = 1, j = n; i &lt; 2*n -1; i+=2, j++) { tmp = nums[j]; for (k = j; k >=i; k--) { nums[k] = nums[k - 1]; } nums[i] = tmp; } *returnSize = numsSize; return nums; } 另一种解法 时间复杂度：$O(n)$​​​ 空间复杂度：$O(n)$​ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* shuffle(int* nums, int numsSize, int n, int* returnSize){ int *array = malloc(sizeof(int) * numsSize); for (int i = 0; i &lt; n; i++) { array[2 * i] = nums[i]; array[2 * i + 1] = nums[i + n]; } *returnSize = numsSize; return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"猜数字","slug":"猜数字","date":"2021-08-06T23:41:23.000Z","updated":"2021-08-06T23:43:10.924Z","comments":true,"path":"2021/08/07/猜数字/","link":"","permalink":"https://tony2ty.github.io/2021/08/07/%E7%8C%9C%E6%95%B0%E5%AD%97/","excerpt":"","text":"LCP 01. 猜数字难度：简单 小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？ 输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。 示例 1： 输入：guess = [1,2,3], answer = [1,2,3] 输出：3 解释：小A 每次都猜对了。 示例 2： 输入：guess = [2,2,3], answer = [3,2,1] 输出：1 解释：小A 只猜对了第二次。 限制： guess 的长度 = 3 answer 的长度 = 3 guess 的元素取值为 &#123;1, 2, 3&#125; 之一。 answer 的元素取值为 &#123;1, 2, 3&#125; 之一。 通过次数79,321 提交次数93,965 int game(int* guess, int guessSize, int* answer, int answerSize){ int cnt = 0; for (int i = 0; i &lt; guessSize; i++) { if (guess[i] == answer[i]) { cnt++; } } return cnt; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"枚举法","slug":"枚举法","permalink":"https://tony2ty.github.io/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"}]},{"title":"有多少小于当前数字的数字","slug":"有多少小于当前数字的数字","date":"2021-08-06T04:43:52.000Z","updated":"2021-08-06T05:27:52.505Z","comments":true,"path":"2021/08/06/有多少小于当前数字的数字/","link":"","permalink":"https://tony2ty.github.io/2021/08/06/%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"1365. 有多少小于当前数字的数字难度：简单 给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。 换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。 以数组形式返回答案。 示例 1： 输入：nums = [8,1,2,2,3] 输出：[4,0,1,1,3] 解释： 对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]=1 不存在比它小的数字。 对于 nums[2]=2 存在一个比它小的数字：（1）。 对于 nums[3]=2 存在一个比它小的数字：（1）。 对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。 示例 2： 输入：nums = [6,5,4,8] 输出：[2,1,0,3] 示例 3： 输入：nums = [7,7,7,7] 输出：[0,0,0,0] 提示： 2 &lt;= nums.length &lt;= 500 0 &lt;= nums[i] &lt;= 100 通过次数83,023 提交次数100,608 枚举法 时间复杂度：$O(N^2)$​ 空间复杂度：$O(1)$​​ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){ int *array = malloc(sizeof(int) * numsSize); memset(array, 0x00, sizeof(int) * numsSize); for (int i = 0; i &lt; numsSize; i++) { // int val = 0; for (int j = 0; j &lt; numsSize; j++) { if (nums[i] > nums[j]) { array[i]++; } } } *returnSize = numsSize; return array; } 计数排序法 时间复杂度：$O(N+K)$​​ 空间复杂度：$O(K)$​ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){ int *array = malloc(sizeof(int) * 101); memset(array, 0x00, sizeof(int) * 101); for (int i = 0; i &lt; numsSize; i++) { array[nums[i]]++; } for (int i = 1; i &lt; 101; i++) { array[i] += array[i - 1]; // printf(\"%d %d %d\\n\", i, array[i], array[i - 1]); } int *array1 = malloc(sizeof(int) * numsSize); memset(array1, 0x00, sizeof(int) * numsSize); for (int i = 0; i &lt; numsSize; i++) { array1[i] = nums[i] == 0? 0 : array[nums[i] - 1]; } free(array); *returnSize = numsSize; return array1; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"计数排序","slug":"计数排序","permalink":"https://tony2ty.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"name":"枚举法","slug":"枚举法","permalink":"https://tony2ty.github.io/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"}]},{"title":"两个数对之间的最大乘积差","slug":"两个数对之间的最大乘积差","date":"2021-08-05T13:43:57.000Z","updated":"2021-08-05T13:45:40.736Z","comments":true,"path":"2021/08/05/两个数对之间的最大乘积差/","link":"","permalink":"https://tony2ty.github.io/2021/08/05/%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AF%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%E5%B7%AE/","excerpt":"","text":"1913. 两个数对之间的最大乘积差难度：简单 两个数对 (a, b) 和 (c, d) 之间的 乘积差 定义为 (a * b) - (c * d) 。 例如，(5, 6) 和 (2, 7) 之间的乘积差是 (5 * 6) - (2 * 7) = 16 。 给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，使数对 (nums[w], nums[x]) 和 (nums[y], nums[z]) 之间的 乘积差 取到 最大值 。 返回以这种方式取得的乘积差中的 最大值 。 示例 1： 输入：nums = [5,6,2,7,4] 输出：34 解释：可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4) 乘积差是 (6 * 7) - (2 * 4) = 34 示例 2： 输入：nums = [4,2,5,9,7,4,8] 输出：64 解释：可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4) 乘积差是 (9 * 8) - (2 * 4) = 64 提示： 4 &lt;= nums.length &lt;= 104 1 &lt;= nums[i] &lt;= 104 通过次数6,547 提交次数7,688 int cmp_int(const void* _a , const void* _b)//参数格式固定 { int* a = (int*)_a; //强制类型转换 int* b = (int*)_b; return *a - *b; } int maxProductDifference(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(nums[0]), cmp_int); return nums[numsSize - 1] * nums[numsSize - 2] - nums[0] * nums[1]; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"一维数组的动态和","slug":"一维数组的动态和","date":"2021-08-05T13:36:15.000Z","updated":"2021-08-05T13:38:09.120Z","comments":true,"path":"2021/08/05/一维数组的动态和/","link":"","permalink":"https://tony2ty.github.io/2021/08/05/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/","excerpt":"","text":"1480. 一维数组的动态和难度：简单 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1： 输入：nums = [1,2,3,4] 输出：[1,3,6,10] 解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 输入：nums = [1,1,1,1,1] 输出：[1,2,3,4,5] 解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 输入：nums = [3,1,2,10,1] 输出：[3,4,6,16,17] 提示： 1 &lt;= nums.length &lt;= 1000 -10^6 &lt;= nums[i] &lt;= 10^6 通过次数101,233 提交次数118,552 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* runningSum(int* nums, int numsSize, int* returnSize){ for (int i = 0; i < numsSize - 1; i++) { nums[i + 1] = nums[i + 1] + nums[i]; } *returnSize = numsSize; return nums; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"检查整数及其两倍数是否存在","slug":"检查整数及其两倍数是否存在","date":"2021-08-04T03:32:38.000Z","updated":"2021-08-04T03:34:22.233Z","comments":true,"path":"2021/08/04/检查整数及其两倍数是否存在/","link":"","permalink":"https://tony2ty.github.io/2021/08/04/%E6%A3%80%E6%9F%A5%E6%95%B4%E6%95%B0%E5%8F%8A%E5%85%B6%E4%B8%A4%E5%80%8D%E6%95%B0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/","excerpt":"","text":"1346. 检查整数及其两倍数是否存在难度：简单 给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。 更正式地，检查是否存在两个下标 i 和 j 满足： i != j 0 &lt;= i, j &lt; arr.length arr[i] == 2 * arr[j] 示例 1： 输入：arr = [10,2,5,3] 输出：true 解释：N = 10 是 M = 5 的两倍，即 10 = 2 * 5 。 示例 2： 输入：arr = [7,1,14,11] 输出：true 解释：N = 14 是 M = 7 的两倍，即 14 = 2 * 7 。 示例 3： 输入：arr = [3,1,7,11] 输出：false 解释：在该情况下不存在 N 和 M 满足 N = 2 * M 。 提示： 2 &lt;= arr.length &lt;= 500 -10^3 &lt;= arr[i] &lt;= 10^3 通过次数14,611 提交次数33,456 bool checkIfExist(int* arr, int arrSize){ for (int i = 0; i &lt; arrSize;i++) { if (arr[i] % 2 == 0) { for (int j = 0; j &lt; arrSize; j++) { if (i == j ) { continue; } if (arr[i] == arr[j] * 2) { return true; } } } } return false; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"枚举法","slug":"枚举法","permalink":"https://tony2ty.github.io/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"}]},{"title":"猜数字大小","slug":"猜数字大小","date":"2021-08-03T11:30:14.000Z","updated":"2021-08-03T11:32:20.372Z","comments":true,"path":"2021/08/03/猜数字大小/","link":"","permalink":"https://tony2ty.github.io/2021/08/03/%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/","excerpt":"","text":"374. 猜数字大小难度：简单 猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick &lt; num 1：我选出的数字比你猜的数字大 pick &gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。 示例 1： 输入：n = 10, pick = 6 输出：6 示例 2： 输入：n = 1, pick = 1 输出：1 示例 3： 输入：n = 2, pick = 1 输出：1 示例 4： 输入：n = 2, pick = 2 输出：2 提示： 1 &lt;= n &lt;= 231 - 1 1 &lt;= pick &lt;= n 通过次数78,014 提交次数151,958 /** * Forward declaration of guess API. * @param num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * int guess(int num); */ int guessNumber(int n){ int mid = 0; int low = 0, high = n; while(low &lt;= high) { mid = low + ((high - low) >> 1); if (guess(mid) == -1) { high = mid - 1; } else if (guess(mid) == 1) { low = mid + 1; } else { return mid; } } return mid; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"}]},{"title":"H指数II","slug":"H指数II","date":"2021-08-02T02:29:08.000Z","updated":"2021-08-02T02:33:07.342Z","comments":true,"path":"2021/08/02/H指数II/","link":"","permalink":"https://tony2ty.github.io/2021/08/02/H%E6%8C%87%E6%95%B0II/","excerpt":"","text":"275. H 指数 II难度：中等 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数，citations 已经按照 升序排列 。计算并返回该研究者的 h 指数。 h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 n - h 篇论文每篇被引用次数 不超过 h 次。 提示：如果 h 有多种可能的值，**h 指数** 是其中最大的那个。 请你设计并实现对数时间复杂度的算法解决此问题。 示例 1： 输入：citations = [0,1,3,5,6] 输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。 由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3 。 示例 2： 输入：citations = [1,2,100] 输出：2 提示： n == citations.length 1 &lt;= n &lt;= 105 0 &lt;= citations[i] &lt;= 1000 citations 按 升序排列 通过次数49,047 提交次数105,657 int hIndex(int* citations, int citationsSize){ int h = 0, i = citationsSize - 1; while (i >= 0 &amp;&amp; citations[i] > h) { h++; i--; } return h; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"https://tony2ty.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"和为s的两个数字","slug":"和为s的两个数字","date":"2021-08-02T02:08:11.000Z","updated":"2021-08-02T02:11:54.467Z","comments":true,"path":"2021/08/02/和为s的两个数字/","link":"","permalink":"https://tony2ty.github.io/2021/08/02/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","excerpt":"","text":"剑指 Offer 57. 和为s的两个数字难度：简单 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2： 输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] 限制： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^6 通过次数115,164 提交次数174,358 解题思路 双指针法 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* twoSum(int* nums, int numsSize, int target, int* returnSize){ int *array = malloc(sizeof(int) * 2); for (int i = 0, j = numsSize - 1; i &lt; numsSize &amp;&amp; j > 0;) { int a = nums[i] + nums[j]; if (a == target) { array[0] = nums[i]; array[1] = nums[j]; *returnSize = 2; return array; } else if (a > target) { j--; } else { i++; } } return NULL; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针法","slug":"双指针法","permalink":"https://tony2ty.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"魔术索引","slug":"魔术索引","date":"2021-08-02T01:25:24.000Z","updated":"2021-08-02T02:00:22.493Z","comments":true,"path":"2021/08/02/魔术索引/","link":"","permalink":"https://tony2ty.github.io/2021/08/02/%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/","excerpt":"","text":"面试题 08.03. 魔术索引难度：简单 魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。 示例1: 输入：nums = [0, 2, 3, 4, 5] 输出：0 说明: 0下标的元素为0 示例2: 输入：nums = [1, 1, 1] 输出：1 说明: nums长度在[1, 1000000]之间 此题为原书中的 Follow-up，即数组中可能包含重复元素的版本 通过次数50,537 提交次数74,644 解题思路 枚举法 int findMagicIndex(int* nums, int numsSize){ for (int i = 0; i &lt; numsSize; i++) { if (nums[i] == i) { return i; } } return -1; } 二分查找法 暂未搞明白 不容易理解的方法 int findMagicIndex(int* nums, int numsSize){ for (int i = fmax(0, nums[0]); i &lt; numsSize; i = fmax(i+1, nums[i])) { if (i == nums[i]) { return i; } } return -1; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"枚举法","slug":"枚举法","permalink":"https://tony2ty.github.io/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"}]},{"title":"有序数组中的单一元素","slug":"有序数组中的单一元素","date":"2021-08-01T08:32:58.000Z","updated":"2021-08-29T00:23:02.063Z","comments":true,"path":"2021/08/01/有序数组中的单一元素/","link":"","permalink":"https://tony2ty.github.io/2021/08/01/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/","excerpt":"","text":"540. 有序数组中的单一元素难度：中等 给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。 示例 1: 输入: nums = [1,1,2,3,3,4,4,8,8] 输出: 2 示例 2: 输入: nums = [3,3,7,7,10,11,11] 输出: 10 提示: 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 105 进阶: 采用的方案可以在 O(log n) 时间复杂度和 O(1) 空间复杂度中运行吗？ 通过次数34,007 提交次数58,606 解题思路 枚举法 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 枚举法需要考虑单个元素出现的位置，数组起始位置、数组最后一个，数组中间位置。 int singleNonDuplicate(int* nums, int numsSize){ if (numsSize == 1) { return nums[0]; } if (numsSize == 2) { return 0; } // if (numsSize == 3) // { // if (nums[0] == nums[1] &amp;&amp; // nums[1] != nums[2]) // { // // printf(\"AAAA\\n\"); // return nums[2]; // } // else if (nums[1] == nums[2] &amp;&amp; // nums[0] != nums[2]) // { // // printf(\"BBBB\\n\"); // return nums[0]; // } // } if (nums[0] != nums[1]) { return nums[0]; } if (nums[numsSize - 1] != nums[numsSize - 2]) { return nums[numsSize - 1]; } for (int i = 2; i &lt; numsSize; i++) { if (nums[i - 1] != nums[i - 2] &amp;&amp; nums[i - 1] != nums[i] &amp;&amp; nums[i - 2] != nums[i]) { // printf(\"CCCC\\n\"); return nums[i - 1]; } } return -1; } 二分查找法 解题思路 折半查找，判断mid值左右两边的值分三种情况 nums[mid]与其左边的值相等，则左边剩余个数：mid - 1；右边剩余个数：numsSize - mid - 1 nums[mid]与其右边的值相等，则左边剩余个数：mid ；右边剩余个数：numsSize - mid - 2 nums[mid]与左右两边均不等，则该值为需要的值 最后判断左右两个哪个为奇数，为奇数则表明该侧存在单一元素，则可以计算low、high值。 直到最后low mid high为同一个值，则循环终止。 时间复杂度：$O(logn)$ 空间复杂度：$O(1)$ int singleNonDuplicate(int* nums, int numsSize){ if (numsSize == 1) { return nums[0]; } int low = 0, high = numsSize - 1, mid = 0; int left = 0, right = 0; while (low &lt;= high) { mid = low + ((high - low) >> 1); printf(\"%d %d %d\\n\", low, mid, high); if (mid == 0 || mid == numsSize - 1) { return nums[mid]; } if (nums[mid] == nums[mid + 1]) { left = mid; right = numsSize - 1 - mid; if (left % 2) { high = mid - 1; } else { low = mid + 2; } } else if (nums[mid] == nums[mid - 1]) { left = mid - 1; right = numsSize - mid - 1; if (left % 2) { high = mid - 2; } else { low = mid + 1; } } else { return nums[mid]; } } return -1; } 异或法 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ int singleNonDuplicate(int* nums, int numsSize){ int val = 0; for (int i = 0; i &lt; numsSize; i++) { val ^= nums[i]; } return val; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"},{"name":"枚举法","slug":"枚举法","permalink":"https://tony2ty.github.io/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"},{"name":"异或法","slug":"异或法","permalink":"https://tony2ty.github.io/tags/%E5%BC%82%E6%88%96%E6%B3%95/"}]},{"title":"搜索旋转排序数组","slug":"搜索旋转排序数组","date":"2021-08-01T07:09:09.000Z","updated":"2021-08-01T07:13:36.919Z","comments":true,"path":"2021/08/01/搜索旋转排序数组/","link":"","permalink":"https://tony2ty.github.io/2021/08/01/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"33. 搜索旋转排序数组难度：中等 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 示例 1： 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2： 输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3： 输入：nums = [1], target = 0 输出：-1 提示： 1 &lt;= nums.length &lt;= 5000 -10^4 &lt;= nums[i] &lt;= 10^4 nums 中的每个值都 独一无二 题目数据保证 nums 在预先未知的某个下标上进行了旋转 -10^4 &lt;= target &lt;= 10^4 进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？ 通过次数322,382 提交次数762,041 解题思路 注意升序数组，多次旋转之后有可能变为原来的升序数组。 int search(int* nums, int numsSize, int target){ if (numsSize == 1) { if (target == nums[0]) { return 0; } else { return -1; } } int i, max = 0, min = 0, index; for (i = 1; i &lt; numsSize; i++) { if (nums[i - 1] > nums[i]) { max = nums[i - 1]; min = nums[i]; index = i - 1; break; } } if (i == numsSize) { min = nums[0]; max = nums[numsSize - 1]; index = numsSize - 1; } // printf(\"%d %d %d\\n\", index, max, min); if (target > max || target &lt; min) { return -1; } int low, high,mid; if (target >= nums[0]) { low = 0; high = index; } else { low = index + 1; high = numsSize - 1; } int ret = -1; // printf(\"%d %d\\n\", low, high); while (low &lt;= high) { // printf(\"%d %d\\n\", low, high); mid = low + ((high - low) >> 1); // printf(\"%d %d %d\\n\", low, high, mid); if (target > nums[mid]) { low = mid + 1; } else if (target &lt; nums[mid]) { high = mid - 1; } else { ret = mid; break; } } return ret; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"}]},{"title":"搜索旋转数组","slug":"搜索旋转数组","date":"2021-07-30T02:30:16.000Z","updated":"2021-08-01T07:08:03.125Z","comments":true,"path":"2021/07/30/搜索旋转数组/","link":"","permalink":"https://tony2ty.github.io/2021/07/30/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/","excerpt":"","text":"面试题 10.03. 搜索旋转数组难度：中等 搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。 示例1: 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5 输出: 8（元素5在该数组中的索引） 示例2: 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11 输出：-1 （没有找到） 提示: arr 长度范围在[1, 1000000]之间 通过次数11,444 提交次数28,785 枚举法 int search(int* arr, int arrSize, int target){ int index = 0; int max = 0, min = 0; int min_inx = arrSize; for (int i = 0; i &lt; arrSize; i++) { if (arr[i + 1] &lt; arr[i]) { index = i + 1; max = arr[i]; min = arr[i+1]; break; } } if (target > max || target &lt; min) { return -1; } for (int i = index; i &lt; index + arrSize; i++) { int j = i % arrSize; if (arr[j] == target) { if (j &lt; min_inx) { min_inx = j; } } } if (min_inx != arrSize) { return min_inx; } return -1; } int search(int* arr, int arrSize, int target){ for (int i = 0; i &lt; arrSize; i++) { if (arr[i] == target) { return i; } } return -1; } 二分查找法 找到旋转数组的起始点，根据目标值选择在前半部分或后半部分采用二分法查找。同时需要注意存在相同值的问题，在找到目标值的位置后，还需要向前搜索可能存在的相同值。 int search(int* arr, int arrSize, int target){ int index = 0; int max = 0, min = 0; int min_inx = arrSize; for (int i = 0; i &lt; arrSize; i++) { if (arr[i + 1] &lt; arr[i]) { index = i + 1; max = arr[i]; min = arr[i+1]; break; } } if (target > max || target &lt; min) { return -1; } if (target == arr[0]) { return 0; } int high, low, mid, ret = -1; if (target >= arr[0] &amp;&amp; target &lt;= max) { high = index - 1; low = 0; } else { high = arrSize - 1; low = index; } //printf(\"%d %d\\n\", low, high); while(low &lt;= high) { mid = low + ((high - low) >> 1); //printf(\"%d %d %d\\n\", mid, low, high); if (arr[mid] == target) { ret = mid; break; } else if (target > arr[mid]) { low = mid + 1; } else { high = mid - 1; } } printf(\"%d\\n\", ret); while (ret >=0) { if (arr[ret] == target) { ret--; } else { ret++; break; } } return ret; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"},{"name":"枚举法","slug":"枚举法","permalink":"https://tony2ty.github.io/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"}]},{"title":"平方数之和","slug":"平方数之和","date":"2021-07-30T01:35:06.000Z","updated":"2021-07-30T02:09:54.732Z","comments":true,"path":"2021/07/30/平方数之和/","link":"","permalink":"https://tony2ty.github.io/2021/07/30/%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"633. 平方数之和难度：中等 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。 示例 1： 输入：c = 5 输出：true 解释：1 * 1 + 2 * 2 = 5 示例 2： 输入：c = 3 输出：false 示例 3： 输入：c = 4 输出：true 示例 4： 输入：c = 2 输出：true 示例 5： 输入：c = 1 输出：true 提示： 0 &lt;= c &lt;= 231 - 1 通过次数89,251 提交次数223,187 枚举法 bool judgeSquareSum(int c){ int max = sqrt(c); for (int i = 0; i &lt;= max; i++) { int b = sqrt(c - i * i); if (i * i + b * b == c) { return true; } } return false; } 双指针法 bool judgeSquareSum(int c){ // int max = sqrt(c); // printf(\"%d\\n\", max); int i = 0, j = sqrt(c); for (int i = 0; i &lt;= j;) //注意判断截止条件是i&lt;=j, 不是i &lt;= max { for (; j >= 0;) { // printf(\"%d %d\\n\", i, j); long long val = j * j; val += (long long)i * (long long)i; if (val == c) { return true; } else if (val > c) { j--; } else { i++; } } } return false; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"双指针法","slug":"双指针法","permalink":"https://tony2ty.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"},{"name":"枚举法","slug":"枚举法","permalink":"https://tony2ty.github.io/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"}]},{"title":"寻找重复数","slug":"寻找重复数","date":"2021-07-27T02:39:43.000Z","updated":"2021-07-30T03:41:32.896Z","comments":true,"path":"2021/07/27/寻找重复数/","link":"","permalink":"https://tony2ty.github.io/2021/07/27/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/","excerpt":"","text":"287. 寻找重复数难度：中等 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。 你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。 示例 1： 输入：nums = [1,3,4,2,2] 输出：2 示例 2： 输入：nums = [3,1,3,4,2] 输出：3 示例 3： 输入：nums = [1,1] 输出：1 示例 4： 输入：nums = [1,1,2] 输出：1 提示： 1 &lt;= n &lt;= 105 nums.length == n + 1 1 &lt;= nums[i] &lt;= n nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次 进阶： 如何证明 nums 中至少存在一个重复的数字? 你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？ 通过次数163,325 提交次数245,600 解题思路 使用二分查找法，确定$high、low$之后，计算$mid$值，然后遍历数组统计小于该$mid$值的个数$cnt$，如果$cnt$大于mid，表示小于$mid$​的值里面有重复值。则$high = mid - 1$；如果$cnt$小于$mid$​，表示大于$mid$​​的值里面存在重复值。 难度：由比较值改为统计个数，以及重复值的取值。 int findDuplicate(int* nums, int numsSize){ int val; int low = 1; int high = numsSize - 1; int mid = 0; int cnt = 0; while (low &lt;= high) { mid = (low + high) >> 1; cnt = 0; for (int i = 0; i &lt; numsSize; i++) { if (nums[i] &lt;= mid) { cnt++; } } // printf(\"%d %d\\n\", cnt, mid); if (cnt > mid) { high = mid - 1; val = mid; } else { low = mid + 1; } } return val; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"}]},{"title":"山脉数组的峰顶索引","slug":"山脉数组的峰顶索引","date":"2021-07-26T05:52:26.000Z","updated":"2021-07-26T06:05:45.490Z","comments":true,"path":"2021/07/26/山脉数组的峰顶索引/","link":"","permalink":"https://tony2ty.github.io/2021/07/26/%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/","excerpt":"","text":"852. 山脉数组的峰顶索引难度：简单 符合下列属性的数组 arr 称为 山脉数组 ： arr.length &gt;= 3 存在 $i(0 &lt; i &lt; arr.length - 1)$使得： arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1] 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] 的下标 i 。 示例 1： 输入：arr = [0,1,0] 输出：1 示例 2： 输入：arr = [0,2,1,0] 输出：1 示例 3： 输入：arr = [0,10,5,2] 输出：1 示例 4： 输入：arr = [3,4,5,1] 输出：2 示例 5： 输入：arr = [24,69,100,99,79,78,67,36,26,19] 输出：2 提示： 3 &lt;= arr.length &lt;= 104 0 &lt;= arr[i] &lt;= 106 题目数据保证 arr 是一个山脉数组 进阶：很容易想到时间复杂度 O(n) 的解决方案，你可以设计一个 O(log(n)) 的解决方案吗？ 通过次数80,265 提交次数112,153 int peakIndexInMountainArray(int* arr, int arrSize){ int index = 1; for (int i = 1; i &lt; arrSize - 1; i++) { if (arr[i] > arr[i - 1] &amp;&amp; arr[i] > arr[i + 1]) { index = i; } } return index; } int peakIndexInMountainArray(int* arr, int arrSize){ int index = 1; int low = 0; int high = arrSize - 1; int mid = 0; while(low &lt;= high) { mid = low + ((high - low) >> 1); // printf(\"%d %d %d\\r\\n\", mid, low, high); if (arr[mid] > arr[mid - 1] &amp;&amp; arr[mid] > arr[mid + 1]) { index = mid; break; } else { if (arr[mid - 1] > arr[mid + 1]) { high = mid; } else if (arr[mid - 1] &lt; arr[mid + 1]) { low = mid; } } } return index; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"}]},{"title":"寻找比目标字母大的最小字母","slug":"寻找比目标字母大的最小字母","date":"2021-07-26T05:44:54.000Z","updated":"2021-07-26T05:46:52.813Z","comments":true,"path":"2021/07/26/寻找比目标字母大的最小字母/","link":"","permalink":"https://tony2ty.github.io/2021/07/26/%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D/","excerpt":"","text":"744. 寻找比目标字母大的最小字母难度：简单 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。 在比较时，字母是依序循环出现的。举个例子： 如果目标字母 target = &#39;z&#39; 并且字符列表为 letters = [&#39;a&#39;, &#39;b&#39;]，则答案返回 &#39;a&#39; 示例： 输入: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;a&quot; 输出: &quot;c&quot; 输入: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;c&quot; 输出: &quot;f&quot; 输入: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;d&quot; 输出: &quot;f&quot; 输入: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;g&quot; 输出: &quot;j&quot; 输入: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;j&quot; 输出: &quot;c&quot; 输入: letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;] target = &quot;k&quot; 输出: &quot;c&quot; 提示： letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。 通过次数37,604 提交次数82,130 char nextGreatestLetter(char* letters, int lettersSize, char target){ int low = 0; int high = lettersSize - 1; int mid = 0; int index = 0; while(low &lt;= high) { mid = low + ((high - low) >> 1); // printf(\"%d %d %d\\r\\n\", mid, low, high); if (letters[mid] > target) { if (mid == 0 || letters[mid - 1] &lt;= target) { index = mid; break; } high = mid - 1; } else { low = mid + 1; } } return letters[index]; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"}]},{"title":"两个数组的交集","slug":"两个数组的交集","date":"2021-07-26T05:26:58.000Z","updated":"2021-07-30T03:44:55.347Z","comments":true,"path":"2021/07/26/两个数组的交集/","link":"","permalink":"https://tony2ty.github.io/2021/07/26/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/","excerpt":"","text":"349. 两个数组的交集难度：简单 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 通过次数196,128 提交次数265,970 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){ int *p1, *p2; int n1, n2; if (nums1Size > nums2Size) { p1 = nums1; n1 = nums1Size; p2 = nums2; n2 = nums2Size; } else { p1 = nums2; n1 = nums2Size; p2 = nums1; n2 = nums1Size; } int max = p1[0], min = p1[0]; for(int i = 1; i &lt; n1; i++) { if (p1[i] > max) { max = p1[i]; } if (p1[i] &lt; min) { min = p1[i]; } } int *array = malloc(sizeof(int) * (max - min + 1)); int *array2 = malloc(sizeof(int) * n2); memset(array, 0x00, sizeof(int) * (max - min + 1)); for (int i = 0; i &lt; n1; i++) { array[p1[i] - min]++; } *returnSize = 0; for (int i = 0; i &lt; n2; i++) { if (p2[i] &lt; min || (p2[i] - min >= max - min + 1)) //这个if判断比较重要，提交出错两次因为这个条件判断 { continue; } if (array[p2[i] - min] != 0) { // printf(\"%d %d %d\\n\", p2[i], min, array[p2[i] - min]); array2[(*returnSize)++] = p2[i]; array[p2[i] - min] = 0; } } return array2; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"}]},{"title":"统计作战单位数","slug":"统计作战单位数","date":"2021-07-21T01:26:11.000Z","updated":"2021-07-30T03:45:48.341Z","comments":true,"path":"2021/07/21/统计作战单位数/","link":"","permalink":"https://tony2ty.github.io/2021/07/21/%E7%BB%9F%E8%AE%A1%E4%BD%9C%E6%88%98%E5%8D%95%E4%BD%8D%E6%95%B0/","excerpt":"","text":"1395. 统计作战单位数难度：中等 n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。 每 3 个士兵可以组成一个作战单位，分组规则如下： 从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k] 作战单位需满足： rating[i] &lt; rating[j] &lt; rating[k] 或者 rating[i] &gt; rating[j] &gt; rating[k] ，其中 0 &lt;= i &lt; j &lt; k &lt; n 请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。 示例 1： 输入：rating = [2,5,3,4,1] 输出：3 解释：我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。 示例 2： 输入：rating = [2,1,3] 输出：0 解释：根据题目条件，我们无法组建作战单位。 示例 3： 输入：rating = [1,2,3,4] 输出：4 提示： n == rating.length 3 &lt;= n &lt;= 1000 1 &lt;= rating[i] &lt;= 10^5 rating 中的元素都是唯一的 通过次数13,412 提交次数17,648 解题思路 枚举三元组 时间复杂度为$O(n^3)$，提交会提示超时 int numTeams(int* rating, int ratingSize){ int cnt = 0; for (int i = 0; i &lt; ratingSize - 2; i++) { for (int j = i + 1; j &lt; ratingSize - 1; j++) { for (int m = j + 1; m &lt; ratingSize; m++) { if ((rating[j] > rating[i] &amp;&amp; rating[j] &lt; rating[m]) || ((rating[j] &lt; rating[i] &amp;&amp; rating[j] > rating[m]))) { cnt++; } } } } return cnt; } 枚举中间点可以枚举三元组$(i,j,k)$​​ 中的$j$​​，它是三元组的中间点。在这之后，我们统计： 出现在$j$左侧，且评分比$j$低的个数，计为$iless$ 出现在$j$左侧，且评分比$j$高的个数，计为$imore$ 出现在$j$​右侧，且评分比$j$​低的个数，计为$kless$​ 出现在$j$​​右侧，且评分比$j$​​高的个数，计为$kmore$​​ 最后的情况$=iless* kmore + imore * kless$ int numTeams(int* rating, int ratingSize){ int cnt = 0; for (int i = 1; i &lt; ratingSize - 1; i++) { int iless= 0, imore = 0, kless = 0, kmore = 0; for(int j = 0; j &lt; i; j++) { if (rating[j] &lt; rating[i]) { iless++; } else { imore++; } } for(int m = i+1; m &lt; ratingSize; m++) { if (rating[m] &lt; rating[i]) { kless++; } else { kmore++; } } cnt += iless * kmore + imore * kless; } return cnt; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"比特位计数","slug":"比特位计数","date":"2021-07-21T00:59:04.000Z","updated":"2021-07-21T01:08:39.832Z","comments":true,"path":"2021/07/21/比特位计数/","link":"","permalink":"https://tony2ty.github.io/2021/07/21/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/","excerpt":"","text":"338. 比特位计数难度简单771收藏分享切换为英文接收动态反馈 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2 输出: [0,1,1] 示例 2: 输入: 5 输出: [0,1,1,2,1,2] 进阶: 给出时间复杂度为**O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)**内用一趟扫描做到吗？ 要求算法的空间复杂度为**O(n)**。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 通过次数144,160 提交次数183,063 /** * Note: The returned array must be malloced, assume caller calls free(). */ int soult(int val) { int cnt = 0; while(val != 0) { if (val &amp; 0x01) { cnt++; } val >>= 1; } return cnt; } int* countBits(int n, int* returnSize){ int *array = malloc(sizeof(int) * (n + 1)); array[0] = 0; for (int i = 1; i &lt; n + 1; i++) { array[i] = soult(i); } *returnSize = n + 1; return array; } 改进算法 /** * Note: The returned array must be malloced, assume caller calls free(). */ #if 0 int soult(int val) { int cnt = 0; while(val != 0) { if (val &amp; 0x01) { cnt++; } val >>= 1; } return cnt; } #endif /* 由于，i &amp; (i - 1) 可以把i的最右边的一个1去掉， 例如：1000 &amp; 0111 = 0000 0111 &amp; 0110 = 0110 所以，bitNum(i) = bitNum(i &amp; (i - 1)) + 1，且i &amp; (i - 1) 是比i要小的，所以可以通过这种递推方法计算 */ int* countBits(int n, int* returnSize){ int *array = malloc(sizeof(int) * (n + 1)); array[0] = 0; for (int i = 1; i &lt; n + 1; i++) { // array[i] = soult(i); array[i] = array[i &amp; (i - 1)] + 1; } *returnSize = n + 1; return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"盛最多水的容器","slug":"盛最多水的容器","date":"2021-07-20T03:46:37.000Z","updated":"2021-07-20T03:54:11.448Z","comments":true,"path":"2021/07/20/盛最多水的容器/","link":"","permalink":"https://tony2ty.github.io/2021/07/20/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","excerpt":"","text":"11. 盛最多水的容器难度：中等 给你 n 个非负整数 a1，a2，...，a``n，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2： 输入：height = [1,1] 输出：1 示例 3： 输入：height = [4,3,2,1,4] 输出：16 示例 4： 输入：height = [1,2,1] 输出：2 提示： n = height.length 2 &lt;= n &lt;= 3 * 104 0 &lt;= height[i] &lt;= 3 * 104 通过次数480,744 提交次数756,841 解题思路 采用双指针方案，关键点是如何确定两个指针的移动顺序。时间复杂度是$O(n)$。采用穷举法，时间复杂度为$O(n^2)$。提交后提示代码超时。 int maxArea(int* height, int heightSize){ int val = 0; int max = 0; int i, j = 0; int diff; // for (i = heightSize - 1; i > 0; i--) // { // for (j = 0; j &lt; i; j++) // { // diff = i - j; // val = fmin(height[i], height[j]) * diff; // max = fmax(max, val); // // printf(\"%d %d\\n\", i, j); // } // } for (i = 0, j = heightSize - 1; i != j;) { diff = j - i; val = fmin(height[i], height[j]); max = fmax(val * diff, max); if (height[i] &lt; height[j]) { i++; } else { j--; } } return max; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://tony2ty.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"双指针法","slug":"双指针法","permalink":"https://tony2ty.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"最长回文串","slug":"最长回文串","date":"2021-07-20T02:35:07.000Z","updated":"2021-07-20T02:36:24.385Z","comments":true,"path":"2021/07/20/最长回文串/","link":"","permalink":"https://tony2ty.github.io/2021/07/20/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/","excerpt":"","text":"409. 最长回文串难度：简单 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例 1: 输入: &quot;abccccdd&quot; 输出: 7 解释: 我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。 通过次数83,922 提交次数151,267 int longestPalindrome(char * s){ if (s == NULL) { return 0; } int array[52]; int length = strlen(s); memset(array, 0x0, sizeof(int) * 52); for (int i = 0; i &lt; length; i++) { if(s[i] >= 'a' &amp;&amp; s[i] &lt;= 'z') { array[s[i] - 'a']++; } else if(s[i] >= 'A' &amp;&amp; s[i] &lt;= 'Z') { array[s[i] - 'A' + 26]++; } } // while(s != NULL) // { // printf(\"%c \", *s); // if((*s) >= 'a' &amp;&amp; (*s) &lt;= 'z') // { // array[(*s) - 'a']++; // } // else if((*s) >= 'A' &amp;&amp; (*s) &lt;= 'Z') // { // array[(*s) - 'A' + 26]++; // } // s++; // } int val = 0; int a = 0; for (int i = 0; i &lt; 52; i++) { // printf(\"%d \", array[i]); if (array[i] > 0 &amp;&amp; array[i] % 2 == 0) { val += array[i]; } else if (array[i] > 1 &amp;&amp; array[i] % 2 != 0) { val += array[i] - 1; a = 1; } else if (array[i] == 1) { a = 1; } } val += a; return val; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://tony2ty.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://tony2ty.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"买卖股票的最佳时机II","slug":"买卖股票的最佳时机II","date":"2021-07-20T02:01:58.000Z","updated":"2021-07-20T02:29:23.729Z","comments":true,"path":"2021/07/20/买卖股票的最佳时机II/","link":"","permalink":"https://tony2ty.github.io/2021/07/20/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/","excerpt":"","text":"122. 买卖股票的最佳时机 II难度：简单 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: prices = [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: prices = [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: prices = [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 3 * 104 0 &lt;= prices[i] &lt;= 104 通过次数406,444 提交次数595,839 int maxProfit(int* prices, int pricesSize){ if (prices == NULL) { return 0; } int val = 0; for (int i = 1; i &lt; pricesSize; i++) { if (prices[i] > prices[i - 1]) { val += prices[i] - prices[i - 1]; } } return val; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://tony2ty.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"树莓派视频监控","slug":"树莓派视频监控","date":"2021-07-17T07:25:57.000Z","updated":"2021-07-17T07:44:12.371Z","comments":true,"path":"2021/07/17/树莓派视频监控/","link":"","permalink":"https://tony2ty.github.io/2021/07/17/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7/","excerpt":"","text":"树莓派+motion视频监控方案树莓派+USB摄像头+motion软件 实现确认USB摄像头设备号使用命令ls /dev/video*，下图两次命令是USB摄像头插拔前后的记录。可知USB摄像头设备号是/dev/video0与/dev/video1。 检查拍照功能安装fswebcam，检查拍照功能。 sudo apt-get install fswebcam 使用以下命令拍照。检查生成的图片。 fswebcam --no-banner -r 640*480 camera.jpg 安装motion使用如下命令安装 sudo apt-get install motion 修改motion.conf配置文件 sudo vim /etc/motion/motion.conf 具体修改内容如下： daemon 的值修改为 on，让 motion 后台运行 rotate 旋转画面，如果需要90°、180°旋转，可以在这里配置 width 和 height 修改画面分辨率（默认为 320*240 像素），我修改成了 1024 和 768 framerate 捕获的帧率，我修改为了 30 stream_maxrate 修改流的帧率，因为我们需要实时查看，这个默认值是 1，会导致画面非常卡顿，我这里修改成了 30 stream_localhost 的值修改为 off，允许通过非 localhost 来查看视频 上面配置中需要注意： 画面分辨率越高越消耗资源 如果画面非常卡，可以调整 stream_maxrate 和 framerate 找到一个合适你的值 配置完成后保存并退出。 运行执行如下命令即可。 sudo motion 在浏览器上访问 http://树莓派地址:8081/ 即可查看到画面。 参考https://bun.plus/posts/monitoring-with-raspberry-pi-and-motion","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://tony2ty.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"视频监控","slug":"视频监控","permalink":"https://tony2ty.github.io/tags/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7/"}]},{"title":"归并与快排","slug":"归并与快排","date":"2021-07-17T05:43:40.000Z","updated":"2021-07-17T05:46:33.042Z","comments":true,"path":"2021/07/17/归并与快排/","link":"","permalink":"https://tony2ty.github.io/2021/07/17/%E5%BD%92%E5%B9%B6%E4%B8%8E%E5%BF%AB%E6%8E%92/","excerpt":"","text":"归并与快排概述归并、快排（快速排序）、堆排序时间复杂度都是$O(nlogn)$。 归并原理 代码实现 性能分析 快排原理 代码实现 性能分析 堆排序原理 代码实现 性能分析","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://tony2ty.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"线性排序","slug":"线性排序","date":"2021-07-16T12:41:36.000Z","updated":"2021-07-16T14:48:01.673Z","comments":true,"path":"2021/07/16/线性排序/","link":"","permalink":"https://tony2ty.github.io/2021/07/16/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/","excerpt":"","text":"线性排序1. 概述之所以叫线性排序，是因为排序算法的时间复杂度为$O(n)$。包括桶排序、计数排序、基数排序。 2. 桶排序2.1 原理将n个数据平均分到$m$个桶（有序桶）中，每个桶分$k$ 个数据，$k = n/m$。对每个桶使用快速排序，则总的时间夫复杂度$m * klogk = nlog \\frac{n}{m}$，如果$m$接近于$n$，则时间复杂度接近于$O(n)$。 分为三步 一、将数据划分到$m$个桶内 二、对每个桶内数据使用快速排序算法 三、将所有桶内数据组合起来即可 2.2 限制桶排序如此优秀，是不是可以用桶排序代替其他排序方法？不能代替，因为桶排序堆数据的要求比较高， 一是，数据能划分到$m$个桶内，且桶与桶之间是有序的。 二是，数据能均匀到分布到每个桶内，最坏情况数据集中在一个桶内。 比如将500W考生的高考分数按照高低排序，此时就能使用桶排序，比如分数在0~750之间，此时就能使用751个桶，每个桶对应分数相同的考生，此时按照从高到底的顺序依次输出即可。 2.3 代码实现2.4 性能分析2.4.1 执行效率时间复杂度为$O(n)$ 2.4.2 内存消耗空间复杂度为$O(n)$？ 2.4.3 稳定性桶排序的稳定性取决于桶内排序使用的算法。桶内排序采用归并排序则稳定，采用快排则非稳定。 3. 计数排序3.1 原理计数排序是桶排序的特例， 假设只有8个考生，分数在0到5分之间。这8个考生的成绩我们放在一个数组A[8]中，它们分别是：2，5，3，0，2，3，0，3。 考生的成绩从0到5分，我们使用大小为6的数组C[6]表示桶，其中下标对应分数。 我们对C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数k的考生个数。 从后到前依次扫描数组A。比如，当扫描到3时，我们可以从数组C中取出下标为3的值7，即到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R中的第7个元素（也就是数组R中下标为6的位置）。当3放入到数组R中后，小于等于3的元素就只剩下了6个了，所以相应的C[3]要减1，变成6。以此类推，当我们扫描到第2个分数为3的考生的时候，就会把它放入数组R中的第6个元素的位置（也就是下标为5的位置）。当我们扫描完整个数组A后，数组R内的数据就是按照分数从小到大有序排列了。 3.2 代码实现void countingSort(int a[], int n) { if (n","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"线性排序","slug":"线性排序","permalink":"https://tony2ty.github.io/tags/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/"}]},{"title":"丢失的数字","slug":"丢失的数字","date":"2021-07-16T06:52:54.000Z","updated":"2021-07-16T12:41:09.755Z","comments":true,"path":"2021/07/16/丢失的数字/","link":"","permalink":"https://tony2ty.github.io/2021/07/16/%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"268. 丢失的数字难度：简单 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 进阶： 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题? 示例 1： 输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2： 输入：nums = [0,1] 输出：2 解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3： 输入：nums = [9,6,4,2,3,5,7,0,1] 输出：8 解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4： 输入：nums = [0] 输出：1 解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 提示： n == nums.length 1 &lt;= n &lt;= 104 0 &lt;= nums[i] &lt;= n nums 中的所有数字都 独一无二 通过次数136,899 提交次数221,382 int missingNumber(int* nums, int numsSize){ int max = nums[0]; int ret = -1; for (int i = 1; i &lt; numsSize; i++) { if (max &lt; nums[i]) { max = nums[i]; } } int *array = malloc(sizeof(int) * (max + 1)); for (int i = 0; i &lt; max + 1; i++) { array[i] = 0; } for (int i = 0; i &lt; numsSize; i++) { array[nums[i]]++; } // for (int i = 0; i &lt; max + 1; i++) // { // printf(\"%d %d\", array[i], max); // } for (int i = 0; i &lt; max+1; i++) { if (array[i] == 0) { ret = i; break; } } if (ret == -1) { ret = numsSize; } return ret; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"}]},{"title":"H指数","slug":"H指数","date":"2021-07-16T05:44:10.000Z","updated":"2021-07-16T12:41:09.746Z","comments":true,"path":"2021/07/16/H指数/","link":"","permalink":"https://tony2ty.github.io/2021/07/16/H%E6%8C%87%E6%95%B0/","excerpt":"","text":"274. H 指数难度：中等 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。 例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。 示例： 输入：citations = [3,0,6,1,5] 输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。 提示：如果 h 有多种可能的值，h 指数是其中最大的那个。 通过次数50,504 提交次数115,035 /** * Note: The returned array must be malloced, assume caller calls free(). */ void countingSort(int* nums, int numsSize) { int max = nums[0]; for (int i = 1; i &lt; numsSize; i++) { if (nums[i] > max) { max = nums[i]; } } int *c = malloc(sizeof(int) * (max + 1)); memset(c, 0x00, sizeof(int) * (max + 1)); for (int i = 0; i &lt; numsSize; i++) { c[nums[i]]++; } for (int i = 1; i &lt;= max; i++) { c[i] = c[i-1] + c[i]; } int *r = malloc(sizeof(int) * numsSize); int index; for (int i = numsSize - 1; i >= 0; i--) { index = c[nums[i]] - 1; r[index] = nums[i]; c[nums[i]]--; } for (int i = 0; i &lt; numsSize; i++) { nums[i] = r[i]; } free(r); free(c); } int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int hIndex(int* citations, int citationsSize){ if (citations == NULL) { return 0; } // countingSort(citations, citationsSize); qsort(citations, citationsSize, sizeof(int), cmpfunc); // for (int i = 0; i &lt; citationsSize; i++) // { // printf(\"%d \", citations[i]); // } int h = 0, i = citationsSize - 1; while(i >= 0 &amp;&amp; citations[i] > h) { h++; i--; } return h; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"https://tony2ty.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"数组的相对排序","slug":"数组的相对排序","date":"2021-07-16T03:49:20.000Z","updated":"2021-07-16T12:41:09.772Z","comments":true,"path":"2021/07/16/数组的相对排序/","link":"","permalink":"https://tony2ty.github.io/2021/07/16/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"1122. 数组的相对排序难度：简单 给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： 1 &lt;= arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 通过次数61,824 提交次数87,500 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize){ if (arr1 == NULL || arr2 == NULL) { return NULL; } int max = arr1[0]; for (int i = 1; i &lt; arr1Size; i++) { if (arr1[i] > max) { max = arr1[i]; } } int *array = malloc(sizeof(int) * (max + 1)); for (int i = 0; i &lt; max + 1; i++) { array[i] = 0; } for (int i = 0; i &lt; arr1Size; i++) { array[arr1[i]]++; } int *buff = malloc(sizeof(int) * arr1Size); int index = 0; for (int i = 0; i &lt; arr2Size; i++) { while(array[arr2[i]] != 0) { buff[index++] = arr2[i]; array[arr2[i]]--; } } for (int i = 0; i &lt; max + 1; i++) { if (array[i] != 0) { for (int j = 0; j &lt; array[i]; j++) { buff[index++] = i; } } } *returnSize = index; return buff; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"计数排序","slug":"计数排序","permalink":"https://tony2ty.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"}]},{"title":"寻找两个正序数组的中位数","slug":"寻找两个正序数组的中位数","date":"2021-07-16T02:47:40.000Z","updated":"2021-07-16T12:41:09.766Z","comments":true,"path":"2021/07/16/寻找两个正序数组的中位数/","link":"","permalink":"https://tony2ty.github.io/2021/07/16/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"","text":"4. 寻找两个正序数组的中位数难度：困难 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.00000 提示： nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -106 &lt;= nums1[i], nums2[i] &lt;= 106 进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？ void merge(int* buff, int first, int mid, int last) { int* tmp = (int *)malloc(sizeof(int) * (last - first + 1)); int left_first = first; int left_last = mid; int right_first = mid + 1; int right_last = last; int k; for (k = 0; left_first &lt;= left_last &amp;&amp; right_first &lt;= right_last; k++) { if (buff[left_first] &lt;= buff[right_first]) { tmp[k] = buff[left_first++]; } else { tmp[k] = buff[right_first++]; } } // printf(\"\\r\\n%d %d %d %d\\r\\n\", left_first, left_last, right_first, right_last); if (left_first &lt;= left_last) { for (int m = left_first; m &lt;= left_last; m++) { tmp[k++] = buff[m]; } } if (right_first &lt;= right_last) { for (int m = right_first; m &lt;= right_last; m++) { tmp[k++] = buff[m]; } } memcpy(buff, tmp, sizeof(int) * (last - first + 1)); free(tmp); } double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){ if (nums1 == NULL || nums2 == NULL) { return 0.0; } int *array = malloc(sizeof(int) * (nums1Size + nums2Size)); memcpy(array, nums1, sizeof(int) * nums1Size); memcpy(&amp;array[nums1Size], nums2, sizeof(int) * nums2Size); //merge(array, 0, nums1Size, nums1Size + nums2Size); merge(array, 0, nums1Size - 1, nums1Size + nums2Size - 1); //这个地方的坑比较深,上面的写法会引起堆栈溢出 double val = 0; if ((nums1Size + nums2Size) % 2 == 1) { val = array[(nums1Size + nums2Size +1) / 2 - 1]; } else { val = (array[(nums1Size + nums2Size) / 2] + array[(nums1Size + nums2Size) / 2 - 1]) / 2.0; } // for (int i = 0; i &lt; nums1Size + nums2Size; i++) // { // printf(\"%d \", array[i]); // } return val; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"https://tony2ty.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"排序数组","slug":"排序数组","date":"2021-07-15T14:04:29.000Z","updated":"2021-07-15T14:06:35.270Z","comments":true,"path":"2021/07/15/排序数组/","link":"","permalink":"https://tony2ty.github.io/2021/07/15/%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"912. 排序数组难度：中等 给你一个整数数组 nums，请你将该数组升序排列。 示例 1： 输入：nums = [5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：nums = [5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 &lt;= nums.length &lt;= 50000 -50000 &lt;= nums[i] &lt;= 50000 通过次数177,244 提交次数308,681 /** * Note: The returned array must be malloced, assume caller calls free(). */ void countingSort(int* nums, int numsSize) { int min = nums[0]; for (int i = 1; i &lt; numsSize; i++) { if (nums[i] &lt; min) { min = nums[i]; } } if (min &lt; 0) { for (int i = 0; i &lt; numsSize; i++) { nums[i] += -min; } } int max = nums[0]; for (int i = 1; i &lt; numsSize; i++) { if (nums[i] > max) { max = nums[i]; } } int *c = malloc(sizeof(int) * (max + 1)); memset(c, 0x00, sizeof(int) * (max + 1)); for (int i = 0; i &lt; numsSize; i++) { c[nums[i]]++; } for (int i = 1; i &lt;= max; i++) { c[i] = c[i-1] + c[i]; } int *r = malloc(sizeof(int) * numsSize); int index; for (int i = numsSize - 1; i >= 0; i--) { index = c[nums[i]] - 1; r[index] = nums[i]; c[nums[i]]--; } for (int i = 0; i &lt; numsSize; i++) { nums[i] = r[i]; } if (min &lt; 0) { for (int i = 0; i &lt; numsSize; i++) { nums[i] += min; } } free(r); free(c); } int* sortArray(int* nums, int numsSize, int* returnSize){ if (nums == NULL) { return NULL; } if (numsSize == 1) { *returnSize = numsSize; return nums; } countingSort(nums, numsSize); *returnSize = numsSize; return nums; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"快速排序","slug":"快速排序","permalink":"https://tony2ty.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"字符串的排列","slug":"字符串的排列","date":"2021-07-14T08:52:16.000Z","updated":"2021-07-15T14:00:51.346Z","comments":true,"path":"2021/07/14/字符串的排列/","link":"","permalink":"https://tony2ty.github.io/2021/07/14/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","excerpt":"","text":"567. 字符串的排列难度：中等 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的 子串 。 示例 1： 输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot; 输出: True 解释: s2 包含 s1 的排列之一 (&quot;ba&quot;). 示例 2： 输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot; 输出: False 提示： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 解题思路 该题麻烦之处在于子串的顺序不关，开始使用的计算子串的ASCII码和有问题，子串$abc$与子串$bbb$的ascii值和相同。 bool checkInclusion(char * s1, char * s2){ if (s1 == NULL || s2 == NULL) { return false; } int m = strlen(s1); int n = strlen(s2); bool ret = false; if (m > n) { return false; } int array1[26] = {0}; for (int j = 0; j &lt; m; j++) { array1[s1[j] - 'a']++; } int array2[26] = {0}; for (int i = 0; i &lt; n + 1 - m; i++) { memset(array2, 0x00, sizeof(int) * 26); for (int j = i; j &lt; m + i; j++) { array2[s2[j] - 'a']++; } if (memcmp(array1, array2, sizeof(int) * 26) == 0) { return true; } } return false; } bool equals(int* cnt1, int* cnt2) { for (int i = 0; i &lt; 26; i++) { if (cnt1[i] != cnt2[i]) { return false; } } return true; } bool checkInclusion(char * s1, char * s2){ if (s1 == NULL || s2 == NULL) { return false; } int m = strlen(s1); int n = strlen(s2); bool ret = false; if (m > n) { return false; } int array1[26] = {0}; for (int j = 0; j &lt; m; j++) { array1[s1[j] - 'a']++; } int array2[26] = {0}; for (int i = 0; i &lt; n + 1 - m; i++) { memset(array2, 0x00, sizeof(int) * 26); for (int j = i; j &lt; m + i; j++) { array2[s2[j] - 'a']++; } if (equals(array1, array2)) { return true; } // if (memcmp(array1, array2, sizeof(int) * 26) == 0) // { // return true; // } } return false; } 改进之处 数组$array2$不需要每次清空，滑动窗口，在尾部新增一个后，删除第一个即可。 bool equals(int* cnt1, int* cnt2) { for (int i = 0; i &lt; 26; i++) { if (cnt1[i] != cnt2[i]) { return false; } } return true; } bool checkInclusion(char * s1, char * s2){ if (s1 == NULL || s2 == NULL) { return false; } int m = strlen(s1); int n = strlen(s2); bool ret = false; if (m > n) { return false; } int array1[26] = {0}; int array2[26] = {0}; for (int j = 0; j &lt; m; j++) { array1[s1[j] - 'a']++; array2[s2[j] - 'a']++; } if (equals(array1, array2)) { return true; } for (int i = m; i &lt; n; i++) { array2[s2[i] - 'a']++; array2[s2[i - m] - 'a']--; // for (int j = i; j &lt; m + i; j++) // { // array2[s2[j] - 'a']++; // } if (equals(array1, array2)) { return true; } // if (memcmp(array1, array2, sizeof(int) * 26) == 0) // { // return true; // } } return false; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"字符串","slug":"字符串","permalink":"https://tony2ty.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"多数元素","slug":"多数元素","date":"2021-07-14T07:40:19.000Z","updated":"2021-09-03T01:11:11.513Z","comments":true,"path":"2021/07/14/多数元素/","link":"","permalink":"https://tony2ty.github.io/2021/07/14/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/","excerpt":"","text":"169. 多数元素难度：简单 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 输入：[3,2,3] 输出：3 示例 2： 输入：[2,2,1,1,1,2,2] 输出：2 进阶： 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。 性能分析 时间复杂度：$O(n^2)$​​​​ 空间复杂度：$O(1)$ int majorityElement(int* nums, int numsSize){ if (numsSize == 1) { return nums[0]; } for (int i = 1; i &lt; numsSize; i++) { int val = nums[i]; int j; for (j = i - 1; j >= 0; j--) { if (nums[j] > val) { nums[j+1] = nums[j]; } else { break; } } nums[j+1] = val; } return nums[numsSize / 2]; } 另一种解法 int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int majorityElement(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), cmpfunc); return nums[numsSize/2]; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"https://tony2ty.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"颜色分类","slug":"颜色分类","date":"2021-07-14T07:06:00.000Z","updated":"2021-07-15T14:00:51.408Z","comments":true,"path":"2021/07/14/颜色分类/","link":"","permalink":"https://tony2ty.github.io/2021/07/14/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","excerpt":"","text":"75. 颜色分类难度：中等 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 示例 1： 输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2] 示例 2： 输入：nums = [2,0,1] 输出：[0,1,2] 示例 3： 输入：nums = [0] 输出：[0] 示例 4： 输入：nums = [1] 输出：[1] 提示： n == nums.length 1 &lt;= n &lt;= 300 nums[i] 为 0、1 或 2 进阶： 你可以不使用代码库中的排序函数来解决这道题吗？ 你能想出一个仅使用常数空间的一趟扫描算法吗？ void sortColors(int* nums, int numsSize){ if (nums == NULL) { return NULL; } if (numsSize &lt;= 1) { return; } for(int i = 1; i &lt; numsSize; i++) { int val = nums[i]; int j; for (j = i - 1; j >= 0; j--) { if (nums[j] > val) { nums[j + 1] = nums[j]; } else { break; } } printf(\"%d\\n\", j); nums[j+1] = val; // 插入数据 } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"https://tony2ty.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"乘积最大子数组","slug":"乘积最大子数组","date":"2021-07-14T06:21:18.000Z","updated":"2021-07-15T14:00:51.270Z","comments":true,"path":"2021/07/14/乘积最大子数组/","link":"","permalink":"https://tony2ty.github.io/2021/07/14/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/","excerpt":"","text":"152. 乘积最大子数组难度：中等 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1: 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 int maxProduct(int* nums, int numsSize){ int maxF = nums[0], minF = nums[0], ans = nums[0]; for (int i = 1; i &lt; numsSize; ++i) { int mx = maxF, mn = minF; maxF = fmax(mx * nums[i], fmax(nums[i], mn * nums[i])); minF = fmin(mn * nums[i], fmin(nums[i], mx * nums[i])); ans = fmax(maxF, ans); } return ans; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"二叉树的后序遍历","slug":"二叉树的后序遍历","date":"2021-07-13T08:28:24.000Z","updated":"2021-07-15T14:00:51.303Z","comments":true,"path":"2021/07/13/二叉树的后序遍历/","link":"","permalink":"https://tony2ty.github.io/2021/07/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"145. 二叉树的后序遍历难度：简单 给定一个二叉树，返回它的 后序 遍历。 示例: 输入: [1,null,2,3] 1 \\ 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ void postorder(struct TreeNode* root, int* buff, int* returnSize){ if (root == NULL) { return; } postorder(root->left, buff, returnSize); postorder(root->right, buff, returnSize); buff[(*returnSize)++] = root->val; } /** * Note: The returned array must be malloced, assume caller calls free(). */ int* postorderTraversal(struct TreeNode* root, int* returnSize){ int *buff = malloc(sizeof(int) * 100); *returnSize = 0; postorder(root, buff, returnSize); return buff; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"二叉树的前序遍历","slug":"二叉树的前序遍历","date":"2021-07-13T08:22:55.000Z","updated":"2021-07-15T14:00:51.294Z","comments":true,"path":"2021/07/13/二叉树的前序遍历/","link":"","permalink":"https://tony2ty.github.io/2021/07/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"144. 二叉树的前序遍历难度简单604收藏分享切换为英文接收动态反馈 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例 1： 输入：root = [1,null,2,3] 输出：[1,2,3] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[1,2] 示例 5： 输入：root = [1,null,2] 输出：[1,2] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶：递归算法很简单，你可以通过迭代算法完成吗？ /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ void preorder(struct TreeNode* root, int *buff, int *returnSize) { if (root == NULL) { return; } buff[(*returnSize)++] = root->val; preorder(root->left, buff, returnSize); preorder(root->right, buff, returnSize); } /** * Note: The returned array must be malloced, assume caller calls free(). */ int* preorderTraversal(struct TreeNode* root, int* returnSize){ // if (root == NULL) // { // return NULL; // } *returnSize = 0; int *buff = malloc(sizeof(int) * 100); preorder(root, buff, returnSize); return buff; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"链表的中间结点","slug":"链表的中间结点","date":"2021-07-13T08:10:10.000Z","updated":"2021-07-15T14:00:51.401Z","comments":true,"path":"2021/07/13/链表的中间结点/","link":"","permalink":"https://tony2ty.github.io/2021/07/13/%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/","excerpt":"","text":"876. 链表的中间结点难度：简单 给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* middleNode(struct ListNode* head){ if (head == NULL) { return NULL; } int cnt = 0; struct ListNode *p = head; while(p != NULL) { cnt++; p = p->next; } printf(\"%d\\n\", cnt); // return head; p = head; int i = 0; while(i &lt; cnt/2) { p = p->next; i++; } return p; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"删除并获得点数","slug":"删除并获得点数","date":"2021-07-12T12:11:47.000Z","updated":"2021-07-12T12:20:26.109Z","comments":true,"path":"2021/07/12/删除并获得点数/","link":"","permalink":"https://tony2ty.github.io/2021/07/12/%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/","excerpt":"","text":"740. 删除并获得点数难度：中等 给你一个整数数组 nums ，你可以对它进行一些操作。 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 示例 1： 输入：nums = [3,4,2] 输出：6 解释： 删除 4 获得 4 个点数，因此 3 也被删除。 之后，删除 2 获得 2 个点数。总共获得 6 个点数。 示例 2： 输入：nums = [2,2,3,3,3,4] 输出：9 解释： 删除 3 获得 3 个点数，接着要删除两个 2 和 4 。 之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。 总共获得 9 个点数。 提示： 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= nums[i] &lt;= 104 动态规划法 int rob(int *nums, int numsSize) { int first = nums[0], second = fmax(nums[0], nums[1]); for (int i = 2; i &lt; numsSize; i++) { int temp = second; second = fmax(first + nums[i], second); first = temp; } return second; } int deleteAndEarn(int* nums, int numsSize){ if (nums == NULL) { return 0; } int maxVal = 0; for (int i = 0; i &lt; numsSize; i++) { if (nums[i] > maxVal) { maxVal = nums[i]; } } int *array = malloc(sizeof(int) * (maxVal + 1)); memset(array, 0x00, sizeof(int) * (maxVal + 1)); for (int i = 0 ; i &lt; numsSize; i++) { array[nums[i]] += nums[i]; } int array2[maxVal + 1]; array2[0] = array[0]; array2[1] = fmax(array[0], array[1]); for (int i = 2; i &lt; maxVal + 1; i++) { array2[i] = fmax(array[i]+array2[i - 2], array2[i - 1]); } return array2[maxVal]; // return rob(array, maxVal + 1); }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"打家劫舍II","slug":"打家劫舍II","date":"2021-07-12T02:33:03.000Z","updated":"2021-07-12T12:35:31.232Z","comments":true,"path":"2021/07/12/打家劫舍II/","link":"","permalink":"https://tony2ty.github.io/2021/07/12/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/","excerpt":"","text":"213. 打家劫舍 II难度：中等 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 输入：nums = [0] 输出：0 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 1000 解题思路 由于第一间与最后一间不能同时打劫，所有问题就分为两种情况： 打劫第一间，不打劫最后一间 不打劫第一间，打劫最后一间 动态规划法 int rob(int* nums, int numsSize){ if (nums == NULL || numsSize == 0) { return 0; } if (numsSize &lt; 2) { return nums[0]; } if (numsSize &lt; 3) { return fmax(nums[0], nums[1]); } //不盗窃第一间 int array[numsSize]; array[1] = nums[1]; array[2] = fmax(nums[1], nums[2]); for (int i = 3; i &lt; numsSize; i++) { array[i] = fmax(nums[i]+array[i - 2], array[i - 1]); } //盗窃第一间 int array2[numsSize]; array2[0] = nums[0]; array2[1] = fmax(nums[0], nums[1]); for (int i = 2; i &lt; numsSize - 1; i++) { array2[i] = fmax(nums[i]+array2[i - 2], array2[i - 1]); } return fmax(array[numsSize - 1], array2[numsSize - 2]); }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"打家劫舍","slug":"打家劫舍","date":"2021-07-12T01:50:00.000Z","updated":"2021-07-12T12:22:45.200Z","comments":true,"path":"2021/07/12/打家劫舍/","link":"","permalink":"https://tony2ty.github.io/2021/07/12/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","excerpt":"","text":"198. 打家劫舍难度：中等 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 解题思路 缩小问题，变为如何偷k间房子，按照最后k-1间房子偷与不偷，分为两种情况，见下图。 那只要计算$f(k-1)$和$f(k-2)$就行，这样递推下去就可以。当$k=3$时，只要计算$f(2)$和$f(1)$即可。 $f(3) = max(f(2), f(1) + H_2)$，其中$f(k)$为累计值，$H_{k-1}$为$K-1$房间的金额。 动态规划法 int rob(int* nums, int numsSize){ if (nums == NULL || numsSize == 0) { return 0; } if (numsSize &lt; 2) { return nums[0]; } int index = 0; int array[numsSize]; array[0] = nums[0]; array[1] = fmax(nums[0], nums[1]); for (int i = 2; i &lt; numsSize; i++) { array[i] = fmax(nums[i]+array[i - 2], array[i - 1]); } return array[numsSize - 1]; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"反转字符串","slug":"反转字符串","date":"2021-07-12T00:54:52.000Z","updated":"2021-07-12T12:23:02.913Z","comments":true,"path":"2021/07/12/反转字符串/","link":"","permalink":"https://tony2ty.github.io/2021/07/12/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"344. 反转字符串难度：简单 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;] 输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;] 输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 双指针法 void reverseString(char* s, int sSize){ if (s == NULL) { return; } // printf(\"%d\\n\", sSize); for(int i = 0; i &lt; (sSize + 1) / 2; i++) { char tmp = s[i]; s[i] = s[sSize - 1 - i]; s[sSize - 1 - i] = tmp; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","permalink":"https://tony2ty.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"爬楼梯","slug":"爬楼梯","date":"2021-07-11T12:58:02.000Z","updated":"2021-07-12T12:22:09.861Z","comments":true,"path":"2021/07/11/爬楼梯/","link":"","permalink":"https://tony2ty.github.io/2021/07/11/%E7%88%AC%E6%A5%BC%E6%A2%AF/","excerpt":"","text":"70. 爬楼梯难度：简单 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 解题思路 输入： 4 输出： 5 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 + 1 阶 3. 1 阶 + 1 阶 + 2 阶 4. 2 阶 + 1 阶 + 1 阶 5. 2 阶 + 2 阶 分析发现符合斐波那契数列规律 int climbStairs(int n){ int *array = malloc(sizeof(int) * (n+1)); array[0] = 1; array[1] = 1; for(int i = 2; i &lt;= n; i++) { array[i] = array[i-1] + array[i-2]; } return array[n]; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"环形链表","slug":"环形链表","date":"2021-07-11T12:01:02.000Z","updated":"2021-08-03T11:33:46.033Z","comments":true,"path":"2021/07/11/环形链表/","link":"","permalink":"https://tony2ty.github.io/2021/07/11/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","excerpt":"","text":"141. 环形链表难度：简单 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 进阶： 你能用 *O(1)*（即，常量）内存解决此问题吗？ 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 &lt;= Node.val &lt;= 105 pos 为 -1 或者链表中的一个 有效索引 。 快慢指针 思路及算法 本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。 假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。 我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 复杂度分析 时间复杂度：$O(N)$ 空间复杂度：$O(1)$ /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ bool hasCycle(struct ListNode *head) { struct ListNode *fast; struct ListNode *slow; bool ret = true; if (head == NULL || head->next == NULL) { return false; } fast = head->next; slow = head; while (fast != slow) { if (fast == NULL || fast->next == NULL) { ret = false; break; } fast = fast->next->next; slow = slow->next; } return ret; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针法","slug":"双指针法","permalink":"https://tony2ty.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"两数之和II","slug":"两数之和II","date":"2021-07-11T11:26:06.000Z","updated":"2021-08-21T06:26:24.048Z","comments":true,"path":"2021/07/11/两数之和II/","link":"","permalink":"https://tony2ty.github.io/2021/07/11/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII/","excerpt":"","text":"167. 两数之和 II - 输入有序数组难度：简单 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例 1： 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 示例 2： 输入：numbers = [2,3,4], target = 6 输出：[1,3] 示例 3： 输入：numbers = [-1,0], target = -1 输出：[1,2] 提示： 2 &lt;= numbers.length &lt;= 3 * 104 -1000 &lt;= numbers[i] &lt;= 1000 numbers 按 递增顺序 排列 -1000 &lt;= target &lt;= 1000 仅存在一个有效答案 暴力法 时间复杂度：$O(n^2)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){ int cnt = 0; int i,j; bool ret = false; // for(i = 0; i &lt; numbersSize; i++) // { // if (target > 0) // { // if (numbers[i] > target) // { // break; // } // } // else // { // if (numbers[i] > 0) // { // break; // } // } // } cnt = numbersSize; printf(\"%d\\n\", cnt); for (i = 0; i &lt; cnt; i++) { for (j = i + 1; j &lt; cnt; j++) { printf(\"%d %d\\n\", numbers[i], numbers[j]); if ((numbers[i] + numbers[j]) == target) { printf(\"CCC\\n\"); ret = true; break; } } if (ret == true) { break; } } int *array = malloc(sizeof(int) * 2); array[0] = i + 1; array[1] = j + 1; *returnSize = 2; return array; } 提示超出时间限制。 双指针法 时间复杂度：$O(n)$ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* twoSum(int* numbers, int numbersSize, int target, int* returnSize){ int cnt = 0; int i,j; for (i = 0, j = numbersSize - 1; i &lt; numbersSize;) { if ((numbers[i] + numbers[j]) > target) { j--; } else if ((numbers[i] + numbers[j]) &lt; target) { i++; } else { break; } } int *array = malloc(sizeof(int) * 2); array[0] = i + 1; array[1] = j + 1; *returnSize = 2; return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针法","slug":"双指针法","permalink":"https://tony2ty.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"}]},{"title":"移动零","slug":"移动零","date":"2021-07-11T10:45:57.000Z","updated":"2021-07-12T12:26:57.926Z","comments":true,"path":"2021/07/11/移动零/","link":"","permalink":"https://tony2ty.github.io/2021/07/11/%E7%A7%BB%E5%8A%A8%E9%9B%B6/","excerpt":"","text":"283. 移动零难度：简单 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 暴力法 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ void moveZeroes(int* nums, int numsSize){ if (nums == NULL) { return; } int cnt = 0; for (int i = 0; i &lt; numsSize - cnt; ) { if (nums[i] == 0) { for (int j = i; j &lt; numsSize - cnt - 1; j++) { nums[j] = nums[j + 1]; } nums[numsSize - cnt - 1] = 0; cnt++; } else { i++; } } } 双指针方案 时间复杂度：O(1) 空间复杂度：O(n) void moveZeroes(int* nums, int numsSize){ if (nums == NULL) { return; } int j = 0; for (int i = 0; i &lt; numsSize; i++) { if (nums[i] != 0) { nums[j++] = nums[i]; } } for (int i = j; i &lt; numsSize; i++) { nums[i] = 0; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"反转链表","slug":"反转链表","date":"2021-07-11T09:45:59.000Z","updated":"2021-07-12T12:33:30.443Z","comments":true,"path":"2021/07/11/反转链表/","link":"","permalink":"https://tony2ty.github.io/2021/07/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"206. 反转链表难度：简单 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2] 输出：[2,1] 示例 3： 输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 投机取巧法 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* reverseList(struct ListNode* head){ struct ListNode *a = head; struct ListNode *c; struct ListNode *b; int cnt = 0, i = 0; while(a != NULL) { a = a->next; cnt++; } int *array = malloc(sizeof(int) * cnt); a = head; while(a != NULL) { array[i++] = a->val; a = a->next; } a = head; i = 0; while(a != NULL) { a->val = array[cnt - 1 - i]; a = a->next; i++; } return head; } 迭代法 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* reverseList(struct ListNode* head){ struct ListNode *pre = head; struct ListNode *cur = NULL; //注意初始化为NULL，不初始化则会出现异常 struct ListNode *tmp; while(pre != NULL) { tmp = pre->next; pre->next = cur; cur = pre; pre = tmp; } return cur; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"旋转数组","slug":"旋转数组","date":"2021-07-10T03:30:01.000Z","updated":"2021-07-12T12:27:54.802Z","comments":true,"path":"2021/07/10/旋转数组/","link":"","permalink":"https://tony2ty.github.io/2021/07/10/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/","excerpt":"","text":"189. 旋转数组难度：中等 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 进阶： 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 提示： 1 &lt;= nums.length &lt;= 2 * 104 -231 &lt;= nums[i] &lt;= 231 - 1 0 &lt;= k &lt;= 105 解题思路 采用暴力方法会超时，使用链表方式也会超时，可以直接通过找规律的方式实现。 代码 void rotate(int* nums, int numsSize, int k){ if (nums == NULL || numsSize == 1 || k == 0) { return; } int array[numsSize]; for (int i = 0; i &lt; numsSize; i++) { array[(i + k) % numsSize] = nums[i]; printf(\"%d \", (i + k) % numsSize); } memcpy(nums, array, sizeof(int) * numsSize); }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"有序数组的平方","slug":"有序数组的平方","date":"2021-07-10T01:52:34.000Z","updated":"2021-07-12T12:26:03.289Z","comments":true,"path":"2021/07/10/有序数组的平方/","link":"","permalink":"https://tony2ty.github.io/2021/07/10/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/","excerpt":"","text":"977. 有序数组的平方难度：简单 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 代码 int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } /** * Note: The returned array must be malloced, assume caller calls free(). */ int* sortedSquares(int* nums, int numsSize, int* returnSize){ if (nums == NULL) { return NULL; } for (int i = 0; i &lt; numsSize; i++) { if (nums[i] &lt; 0) { nums[i] = -nums[i]; } } qsort(nums, numsSize, sizeof(int), cmpfunc); for (int i = 0; i &lt; numsSize; i++) { nums[i] = nums[i] * nums[i]; } *returnSize = numsSize; return nums; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"移除链表元素","slug":"移除链表元素","date":"2021-07-10T01:40:41.000Z","updated":"2021-07-12T12:27:37.141Z","comments":true,"path":"2021/07/10/移除链表元素/","link":"","permalink":"https://tony2ty.github.io/2021/07/10/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/","excerpt":"","text":"203. 移除链表元素难度：简单 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2： 输入：head = [], val = 1 输出：[] 示例 3： 输入：head = [7,7,7,7], val = 7 输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 代码 struct ListNode* removeElements(struct ListNode* head, int val){ if (head == NULL) { return NULL; } struct ListNode *p; struct ListNode *q = malloc(sizeof(struct ListNode)); p = q; q->next = head; while(q->next != NULL) { if (q->next->val == val) { q->next = q->next->next; } else { q = q->next; } } printf(\"%p %p\\n\", p->next, head); return p->next; } 注意最后返回值应该是p-&gt;next，不应该是head，示例3中，所有节点均删除，则q-&gt;next是NULL，而不是head。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"二分查找","slug":"二分查找","date":"2021-07-09T12:16:33.000Z","updated":"2021-08-03T11:34:15.498Z","comments":true,"path":"2021/07/09/二分查找/","link":"","permalink":"https://tony2ty.github.io/2021/07/09/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"704. 二分查找难度：简单 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 代码 int search(int* nums, int numsSize, int target){ int mid; int first = 0, end = numsSize; while (first &lt; end) { mid = (first + end) / 2; if (target > nums[mid]) { first = mid + 1; } else if (target &lt; nums[mid]) { first = 0; end = mid; } else { return mid; } } return -1; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"}]},{"title":"第N个泰波那契数","slug":"第N个泰波那契数","date":"2021-07-09T12:15:30.000Z","updated":"2021-07-12T12:35:21.468Z","comments":true,"path":"2021/07/09/第N个泰波那契数/","link":"","permalink":"https://tony2ty.github.io/2021/07/09/%E7%AC%ACN%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/","excerpt":"","text":"1137. 第 N 个泰波那契数难度：简单 泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。 示例 1： 输入：n = 4 输出：4 解释： T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 示例 2： 输入：n = 25 输出：1389537 提示： 0 &lt;= n &lt;= 37 答案保证是一个 32 位整数，即 answer &lt;= 2^31 - 1。 代码 int tribonacci(int n){ if (n == 0) { return 0; } else if (n &lt;= 2) { return 1; } int *array = malloc(sizeof(int) * n); array[0] = 0; array[1] = 1; array[2] = 1; for (int i = 3; i &lt; n; i++) { array[i] = array[i - 1] + array[i - 2] + array[i - 3]; } return array[n - 1] + array[n - 2] + array[n - 3]; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"斐波那契数","slug":"斐波那契数","date":"2021-07-09T12:11:32.000Z","updated":"2021-07-12T12:33:16.167Z","comments":true,"path":"2021/07/09/斐波那契数/","link":"","permalink":"https://tony2ty.github.io/2021/07/09/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/","excerpt":"","text":"509. 斐波那契数难度：简单 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你 n ，请计算 F(n) 。 示例 1： 输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 代码 int fib(int n){ // if (n == 0) // { // return 0; // } // if (n == 2 || n == 1) // { // return 1; // } if (n &lt;= 1) { return n; } return fib(n - 1) + fib(n - 2); }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://tony2ty.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"实现strStr函数","slug":"实现strStr函数","date":"2021-07-09T12:07:23.000Z","updated":"2021-07-12T12:29:16.403Z","comments":true,"path":"2021/07/09/实现strStr函数/","link":"","permalink":"https://tony2ty.github.io/2021/07/09/%E5%AE%9E%E7%8E%B0strStr%E5%87%BD%E6%95%B0/","excerpt":"","text":"28. 实现 strStr()难度：简单 实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例 1： 输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出：2 示例 2： 输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出：-1 示例 3： 输入：haystack = &quot;&quot;, needle = &quot;&quot; 输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 104 haystack 和 needle 仅由小写英文字符组成 代码 int strStr(char * haystack, char * needle){ if (needle == NULL) { return 0; } int m = strlen(haystack); int n = strlen(needle); if (n == 0) { return 0; } bool ret; for (int i = 0; i &lt; m; i++) { ret = true; for (int j = i; j &lt; n + i; j++) { if (haystack[j] != needle[j - i]) { ret = false; break; } } if (ret == true) { return i; } } return -1; } 超时代码 int strStr(char * haystack, char * needle){ if (needle == NULL) { return 0; } int m = strlen(haystack); int n = strlen(needle); if (n == 0) { return 0; } bool ret = true; int val = -1; for (int i = 0; i &lt; m; i++) { ret = true; for (int j = i; j &lt; n + i; j++) { if (haystack[j] != needle[j - i]) { ret = false; break; } } if (ret == true) { val = i; break; } } return val; } 对比代码未发现明显区别","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://tony2ty.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"有效的括号","slug":"有效的括号","date":"2021-07-09T11:50:26.000Z","updated":"2021-07-12T13:39:42.358Z","comments":true,"path":"2021/07/09/有效的括号/","link":"","permalink":"https://tony2ty.github.io/2021/07/09/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","excerpt":"","text":"20. 有效的括号难度：简单 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 输入：s = &quot;()&quot; 输出：true 示例 2： 输入：s = &quot;()[]&#123;&#125;&quot; 输出：true 示例 3： 输入：s = &quot;(]&quot; 输出：false 示例 4： 输入：s = &quot;([)]&quot; 输出：false 示例 5： 输入：s = &quot;&#123;[]&#125;&quot; 输出：true 提示： 1 &lt;= s.length &lt;= 104 s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成 解题思路 分配一个数组，只要是括号左半边就存入数组，只要是括号右半边则与数组中索引最大值进行匹配，匹配上则数组索引减1。 代码 bool isValid(char * s){ if (s == NULL) { return false; } int n = strlen(s); if (n % 2 == 1) { return false; } char *str = malloc(sizeof(char) * (n + 1)); int index = 0; for (int i = 0; i &lt; n; i++) { if (s[i] == '(' || s[i] == '[' || s[i] == '{') { str[++index] = s[i]; } else { if (s[i] == ')' &amp;&amp; str[index] == '(' ) { index--; } else if (s[i] == ']' &amp;&amp; str[index] == '[' ) { index--; } else if (s[i] == '}' &amp;&amp; str[index] == '{' ) { index--; } else { return false; } } } if (index != 0) { return false; } return true; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"栈","slug":"栈","permalink":"https://tony2ty.github.io/tags/%E6%A0%88/"}]},{"title":"罗马数字转整数","slug":"罗马数字转整数","date":"2021-07-09T11:45:05.000Z","updated":"2021-07-12T12:38:45.971Z","comments":true,"path":"2021/07/09/罗马数字转整数/","link":"","permalink":"https://tony2ty.github.io/2021/07/09/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/","excerpt":"","text":"13. 罗马数字转整数难度：简单 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: &quot;III&quot; 输出: 3 示例 2: 输入: &quot;IV&quot; 输出: 4 示例 3: 输入: &quot;IX&quot; 输出: 9 示例 4: 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 提示： 1 &lt;= s.length &lt;= 15 s 仅含字符 (&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;) 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。 IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。 代码 int romanToInt(char * s){ int index = 0; int val = 0; while (s[index] != '\\0') { if (s[index] == 'I') { switch (s[index + 1]) { case 'V': { val += 4; index++; } break; case 'X': { val += 9; index++; }break; default: val +=1; } } else if (s[index] == 'X') { switch (s[index + 1]) { case 'L': { val += 40; index++; } break; case 'C': { val += 90; index++; }break; default: val +=10; } } else if (s[index] == 'C') { switch (s[index + 1]) { case 'D': { val += 400; index++; } break; case 'M': { val += 900; index++; }break; default: val +=100; } } else if (s[index] == 'V') { val +=5; } else if (s[index] == 'L') { val +=50; } else if (s[index] == 'D') { val +=500; } else if (s[index] == 'M') { val +=1000; } index++; } return val; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"}]},{"title":"有效的字母异位词","slug":"有效的字母异位词","date":"2021-07-09T11:42:50.000Z","updated":"2021-07-12T12:26:21.226Z","comments":true,"path":"2021/07/09/有效的字母异位词/","link":"","permalink":"https://tony2ty.github.io/2021/07/09/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","excerpt":"","text":"242. 有效的字母异位词难度：简单 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true 示例 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false 提示: 1 &lt;= s.length, t.length &lt;= 5 * 104 s 和 t 仅包含小写字母 代码 bool isAnagram(char * s, char * t){ if (s == NULL || t == NULL) { return false; } int table[26] = {0}; int m = strlen(s); int n = strlen(t); for(int i = 0; i &lt; m; i++) { table[s[i] - 'a'] += 1; } for(int i = 0; i &lt; n; i++) { if (table[t[i] - 'a'] == 0) { return false; } else { table[t[i] - 'a']--; } } for(int i = 0; i &lt; 26; i++) { if (table[i] != 0) { return false; } } return true; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"}]},{"title":"赎金信","slug":"赎金信","date":"2021-07-09T11:41:06.000Z","updated":"2021-07-12T12:39:04.107Z","comments":true,"path":"2021/07/09/赎金信/","link":"","permalink":"https://tony2ty.github.io/2021/07/09/%E8%B5%8E%E9%87%91%E4%BF%A1/","excerpt":"","text":"383. 赎金信难度：简单 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 示例 1： 输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot; 输出：false 示例 2： 输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot; 输出：false 示例 3： 输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot; 输出：true 提示： 你可以假设两个字符串均只含有小写字母。 代码 bool canConstruct(char * ransomNote, char * magazine){ if (ransomNote == NULL || magazine == NULL) { return false; } bool ret = true; int table[26] = {0}; int n = strlen(magazine); for (int i = 0; i &lt; n; i++) { table[magazine[i] - 'a'] += 1; } int m = strlen(ransomNote); for (int i = 0; i &lt; m; i++) { if (table[ransomNote[i]- 'a'] == 0) { ret = false; break; } else { table[ransomNote[i]- 'a']--; } } return ret; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"}]},{"title":"字符串中的第一个唯一字符","slug":"字符串中的第一个唯一字符","date":"2021-07-08T13:34:12.000Z","updated":"2021-07-12T12:25:07.164Z","comments":true,"path":"2021/07/08/字符串中的第一个唯一字符/","link":"","permalink":"https://tony2ty.github.io/2021/07/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/","excerpt":"","text":"387. 字符串中的第一个唯一字符难度：简单 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例： s = &quot;leetcode&quot; 返回 0 s = &quot;loveleetcode&quot; 返回 2 提示：你可以假定该字符串只包含小写字母。 解题思路 与出现次数相关的，优先考虑使用散列表方式 代码 int firstUniqChar(char * s){ if (s == NULL) { return -1; } int n = strlen(s); if (n == 0) { return -1; } int table[26] = {0}; int i; for (i = 0; i &lt; n; i++) { table[s[i] - 'a'] += 1; } for (i = 0; i &lt; n; i++) { if (table[s[i] - 'a'] == 1) { return i; } } return -1; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"}]},{"title":"只出现一次的数字","slug":"只出现一次的数字","date":"2021-07-08T13:31:18.000Z","updated":"2021-07-12T12:25:29.902Z","comments":true,"path":"2021/07/08/只出现一次的数字/","link":"","permalink":"https://tony2ty.github.io/2021/07/08/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"136. 只出现一次的数字难度：简单 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 代码 int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int singleNumber(int* nums, int numsSize){ if (nums == NULL) { return 0; } int *array = malloc(sizeof(int) * numsSize); int ret = 0; memcpy(array, nums, sizeof(int) * numsSize); qsort(array, numsSize, sizeof(int), cmpfunc); int i; for (i = 0; i &lt; numsSize - 1;) { // printf(\"%d %d\\n\", array[i], array[i+1]); if (array[i] == array[i+1]) { i += 2; } else { ret = array[i]; break; } // printf(\"%d\", i); } if (numsSize - 1 == i) { ret = array[i]; } return ret; } 优雅解法 int singleNumber(int* nums, int numsSize){ if (nums == NULL) { return 0; } int ret = 0; for (int i = 0; i &lt; numsSize; i++) { ret ^= nums[i]; } return ret; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"搜索插入位置","slug":"搜索插入位置","date":"2021-07-08T13:29:48.000Z","updated":"2021-07-12T12:28:58.278Z","comments":true,"path":"2021/07/08/搜索插入位置/","link":"","permalink":"https://tony2ty.github.io/2021/07/08/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"35. 搜索插入位置难度：简单 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 代码 int searchInsert(int* nums, int numsSize, int target){ if (nums == NULL) { return 0; } if (target &lt; nums[0]) { return 0; } if (target > nums[numsSize - 1]) { return numsSize; } int ret = 0; for (int i = 0; i &lt; numsSize; i++) { if (target == nums[i]) { ret = i; break; } else if (target &lt; nums[i]) { ret = i; break; } } return ret; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"移除元素","slug":"移除元素","date":"2021-07-07T14:36:09.000Z","updated":"2021-07-12T12:27:20.178Z","comments":true,"path":"2021/07/07/移除元素/","link":"","permalink":"https://tony2ty.github.io/2021/07/07/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","excerpt":"","text":"27. 移除元素难度：简单 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125; 示例 1： 输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 代码 int removeElement(int* nums, int numsSize, int val){ if (nums == NULL) { return 0; } int cnt = numsSize; for (int i = 0; i &lt; numsSize;) { if (nums[i] == val) { // printf(\"%d;;;\\n\", i); for (int j = i; j &lt; numsSize - 1; j++) { nums[j] = nums[j+1]; } cnt--; numsSize--; // printf(\"%d\\n\", cnt); } else { i++; } } return cnt; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"加一","slug":"加一","date":"2021-07-07T13:37:26.000Z","updated":"2021-07-12T12:31:58.493Z","comments":true,"path":"2021/07/07/加一/","link":"","permalink":"https://tony2ty.github.io/2021/07/07/%E5%8A%A0%E4%B8%80/","excerpt":"","text":"66. 加一难度：简单 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1： 输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2： 输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3： 输入：digits = [0] 输出：[1] 提示： 1 &lt;= digits.length &lt;= 100 0 &lt;= digits[i] &lt;= 9 代码 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* plusOne(int* digits, int digitsSize, int* returnSize){ if (digits == NULL) { return NULL; } int *array = malloc(sizeof(int) * (digitsSize + 1)); memset(array, 0x00, sizeof(int) * (digitsSize + 1)); int len = digitsSize; int val = digits[len - 1]; char flag = 1; for (int i = len - 1; i >= 0; i--) { if (flag == 1) { val = digits[i] + 1; } else { val = digits[i]; } if (val == 10) { val = 0; flag = 1; } else { flag = 0; } array[i+1] = val; } if (flag == 1) { array[0] = 1; } if (array[0] == 0) { *returnSize = digitsSize; for (int i = 0; i &lt; digitsSize; i++) { array[i] = array[i+1]; } } else { *returnSize = digitsSize + 1; } return array; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"合并两个有序链表","slug":"合并两个有序链表","date":"2021-07-07T12:15:34.000Z","updated":"2021-07-12T12:33:04.254Z","comments":true,"path":"2021/07/07/合并两个有序链表/","link":"","permalink":"https://tony2ty.github.io/2021/07/07/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"","text":"21. 合并两个有序链表难度：简单 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 &lt;= Node.val &lt;= 100 l1 和 l2 均按 非递减顺序 排列 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){ if (l1 == NULL) { return l2; } else if (l2 == NULL) { return l1; } if (l1->val &lt; l2->val) { l1->next = mergeTwoLists(l1->next, l2); return l1; } else { l2->next = mergeTwoLists(l1, l2->next); return l2; } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"删除排序链表中的重复元素","slug":"删除排序链表中的重复元素","date":"2021-07-07T12:13:50.000Z","updated":"2021-07-12T12:30:02.068Z","comments":true,"path":"2021/07/07/删除排序链表中的重复元素/","link":"","permalink":"https://tony2ty.github.io/2021/07/07/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","excerpt":"","text":"83. 删除排序链表中的重复元素难度：简单 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 返回同样按升序排列的结果链表。 示例 1： 输入：head = [1,1,2] 输出：[1,2] 示例 2： 输入：head = [1,1,2,3,3] 输出：[1,2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序排列 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* deleteDuplicates(struct ListNode* head){ if (head == NULL) { return NULL; } struct ListNode *pl = head; while (pl->next != NULL) { if (pl->val == pl->next->val) { pl->next = pl->next->next; } else { pl = pl->next; } } return head; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"两两交换链表中的节点","slug":"两两交换链表中的节点","date":"2021-07-07T12:09:58.000Z","updated":"2021-07-12T12:31:37.455Z","comments":true,"path":"2021/07/07/两两交换链表中的节点/","link":"","permalink":"https://tony2ty.github.io/2021/07/07/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"","text":"24. 两两交换链表中的节点难度：中等 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1： 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head = [] 输出：[] 示例 3： 输入：head = [1] 输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。） 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* swapPairs(struct ListNode* head){ if (head == NULL) { return NULL; } if (head->next == NULL) { return head; } int val; if (head->next->next == NULL) { val = head->val; head->val = head->next->val; head->next->val = val; return head; } struct ListNode *p1 = head; while(p1->next != NULL) { val = p1->val; p1->val = p1->next->val; p1->next->val = val; if (p1->next->next != NULL) { p1 = p1->next->next; } else { break; } } return head; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"删除排序链表中的重复元素II","slug":"删除排序链表中的重复元素II","date":"2021-07-07T12:04:15.000Z","updated":"2021-07-12T12:29:36.202Z","comments":true,"path":"2021/07/07/删除排序链表中的重复元素II/","link":"","permalink":"https://tony2ty.github.io/2021/07/07/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/","excerpt":"","text":"82. 删除排序链表中的重复元素 II难度：中等 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。 返回同样按升序排列的结果链表。 示例 1： 输入：head = [1,2,3,3,4,4,5] 输出：[1,2,5] 示例 2： 输入：head = [1,1,1,2,3] 输出：[2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序排列 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* deleteDuplicates(struct ListNode* head){ if (head == NULL) { return NULL; } if (head->next == NULL) { return head; } struct ListNode *p1 = malloc(sizeof(struct ListNode)); struct ListNode *p2 = p1; // struct ListNode *p3 = p2->next; p2->next = head; int val; while (p2->next != NULL &amp;&amp; p2->next->next != NULL) { if (p2->next->val == p2->next->next->val) { val = p2->next->val; if (p2->next->next->next != NULL) { p2->next = p2->next->next->next; } else { p2->next = NULL; break; } while(p2->next != NULL) { if (val == p2->next->val) { p2->next = p2->next->next; } else { break; } } } else { p2 = p2->next; } } head = p1->next; return head; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"删除链表的倒数第N个结点","slug":"删除链表的倒数第N个结点","date":"2021-07-06T14:45:05.000Z","updated":"2021-07-15T14:00:51.261Z","comments":true,"path":"2021/07/06/删除链表的倒数第N个结点/","link":"","permalink":"https://tony2ty.github.io/2021/07/06/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/","excerpt":"","text":"19. 删除链表的倒数第 N 个结点难度：中等 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 进阶：你能尝试使用一趟扫描实现吗？ 示例 1： 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 需要区分链表长度与待删除倒数节点n的关系。 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* removeNthFromEnd(struct ListNode* head, int n){ int cnt = 0; if (head == NULL) { return NULL; } struct ListNode *p = head; struct ListNode *q = head; while (p != NULL) { cnt++; p = p->next; } printf(\"%d\\n\", cnt); if (n > cnt) { return NULL; } if (n == cnt) { head = head->next; return head; } for (int i = 1; i &lt; cnt - n; i++) { q = q->next; } q->next = q->next->next; return head; } 提交记录","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"买卖股票的最佳时机","slug":"买卖股票的最佳时机","date":"2021-07-06T13:45:53.000Z","updated":"2021-07-12T12:30:30.481Z","comments":true,"path":"2021/07/06/买卖股票的最佳时机/","link":"","permalink":"https://tony2ty.github.io/2021/07/06/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","excerpt":"","text":"121. 买卖股票的最佳时机难度：简单 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 104 代码 int maxProfit(int* prices, int pricesSize){ if (pricesSize &lt;= 1) { return 0; } int max = 0; int min = prices[0]; for (int i = 1; i &lt; pricesSize; i++) { max = fmax(prices[i] - min, max); min = fmin(min, prices[i]); } return max; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"两个数组的交集II","slug":"两个数组的交集II","date":"2021-07-06T13:43:59.000Z","updated":"2021-07-12T12:31:47.944Z","comments":true,"path":"2021/07/06/两个数组的交集II/","link":"","permalink":"https://tony2ty.github.io/2021/07/06/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/","excerpt":"","text":"350. 两个数组的交集 II难度：简单 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 ***进阶*： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ /** * Note: The returned array must be malloced, assume caller calls free(). */ int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){ int *p1, *p2; int size1, size2; if (nums1 == NULL || nums2 == NULL) { return NULL; } if (nums1Size > nums2Size) { p1 = nums1; size1 = nums1Size; p2 = nums2; size2 = nums2Size; } else { p1 = nums2; size1 = nums2Size; p2 = nums1; size2 = nums1Size; } int *p3 = malloc(sizeof(int) * size2); int size3 = 0; char *pflag = malloc(sizeof(char) * size1); memset(pflag, 0x00, sizeof(char) * size1); // printf(\"%d %d\\n\", size1, size2); for (int i = 0; i &lt; size2; i++) { for (int j = 0; j &lt; size1; j++) { if ((p2[i] == p1[j]) &amp;&amp; (pflag[j] == 0)) { p3[size3++] = p2[i]; pflag[j] = 1; break; } } } *returnSize = size3; return p3; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"对称二叉树","slug":"对称二叉树","date":"2021-07-05T12:42:06.000Z","updated":"2021-07-15T14:00:51.259Z","comments":true,"path":"2021/07/05/对称二叉树/","link":"","permalink":"https://tony2ty.github.io/2021/07/05/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"101. 对称二叉树难度：简单 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？ 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ bool soult(struct TreeNode* tn1, struct TreeNode* tn2) { bool ret1 = false; bool ret2 = false; if (tn1 == NULL &amp;&amp; tn2 == NULL) { return true; } if (tn1 == NULL || tn2 == NULL) { return false; } if (tn1->val == tn2->val) { ret1 = soult(tn1->left, tn2->right); ret2 = soult(tn1->right, tn2->left); } return ret1 &amp; ret2; } bool isSymmetric(struct TreeNode* root){ if (root == NULL) { return false; } return soult(root, root); }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"最大子序和","slug":"最大子序和","date":"2021-07-05T12:26:31.000Z","updated":"2021-07-15T14:00:51.243Z","comments":true,"path":"2021/07/05/最大子序和/","link":"","permalink":"https://tony2ty.github.io/2021/07/05/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","excerpt":"","text":"53. 最大子序和难度：简单 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [0] 输出：0 示例 4： 输入：nums = [-1] 输出：-1 示例 5： 输入：nums = [-100000] 输出：-100000 提示： 1 &lt;= nums.length &lt;= 3 * 104 -105 &lt;= nums[i] &lt;= 105 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 代码 int maxSubArray(int* nums, int numsSize){ int ret = nums[0], sum = 0; for (int i = 0; i &lt; numsSize; i++) { sum += nums[i]; ret = ret > sum? ret:sum; if (sum &lt; 0) { sum = 0; } //printf(\"%d %d %d %d\\n\", i, nums[i], sum, ret); } return ret; } 解题思路 假设$nums$数组的长度是$n$，下标从 $0$ 到$n−1$。 我们用 $f(i)$代表以第 $i$个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是： $$\\max \\limits_{0 \\leq x \\leq n-1}{f(x)}$$因此我们只需要求出每个位置的$f(i)$，然后返回$f$数组中的最大值即可。那么我们如何求 $f(i)$呢？我们可以考虑$nums[i]$单独成为一段还是加入 $f(i-1)$对应的那一段，这取决于$nums[i]$和$f(i - 1) + nums[i]$的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：$$f(i)=max{f(i-1)+nums[i], nums[i]}$$不难给出一个时间复杂度$O(n)$、空间复杂度$O(n)$的实现，即用一个$f$ 数组来保存$f(i)$的值，用一个循环求出所有$f(i)$。考虑到$f(i)$只和$f(i-1)$相关，于是我们可以只用一个变量$pre$来维护对于当前$f(i)$的$f(i-1)$的值是多少，从而让空间复杂度降低到$O(1)$，这有点类似「滚动数组」的思想。 int maxSubArray(int* nums, int numsSize){ int pre = 0, max = nums[0]; for (int i = 0; i &lt; numsSize; i++) { pre = fmax(pre+nums[i], nums[i]); max = fmax(pre, max); } return max; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"合并两个有序数组","slug":"合并两个有序数组","date":"2021-07-05T12:22:52.000Z","updated":"2021-07-12T12:32:49.104Z","comments":true,"path":"2021/07/05/合并两个有序数组/","link":"","permalink":"https://tony2ty.github.io/2021/07/05/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"88. 合并两个有序数组难度：简单 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 提示： nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -109 &lt;= nums1[i], nums2[i] &lt;= 109 代码 int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){ if (n == 0) { return; } memcpy(&amp;nums1[m], nums2, n * sizeof(int)); if (n + m >= 2) { qsort(nums1, m + n, sizeof(int), cmpfunc); } }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"相同的树","slug":"相同的树","date":"2021-07-04T12:58:06.000Z","updated":"2021-07-12T12:28:30.327Z","comments":true,"path":"2021/07/04/相同的树/","link":"","permalink":"https://tony2ty.github.io/2021/07/04/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/","excerpt":"","text":"100. 相同的树难度：简单 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1： 输入：p = [1,2,3], q = [1,2,3] 输出：true 示例 2： 输入：p = [1,2], q = [1,null,2] 输出：false 示例 3： 输入：p = [1,2,1], q = [1,1,2] 输出：false 提示： 两棵树上的节点数目都在范围 [0, 100] 内 -104 &lt;= Node.val &lt;= 104 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ void inorder(struct TreeNode* p, struct TreeNode* q, bool *res) { // if ((p != NULL &amp;&amp; q == NULL) || (p == NULL &amp;&amp; q != NULL)) // { // *res = false; // return; // } // else // { // return; // } if ((p != NULL &amp;&amp; q == NULL) || (p == NULL &amp;&amp; q != NULL)) { *res = false; return; } if ((p == NULL) &amp;&amp; (q == NULL)) { return; } inorder(p->left, q->left, res); if (*res != true) { *res = false; return; } if (p->val != q->val) { *res = false; return; } inorder(p->right, q->right, res); if (*res != true) { return; } } bool isSameTree(struct TreeNode* p, struct TreeNode* q){ bool res = true; // if (p == NULL || q == NULL) // { // return false; // } // if (p->val != q->val) // { // return false; // } inorder(p, q, &amp;res); return res; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"存在重复元素","slug":"存在重复元素","date":"2021-07-04T12:38:42.000Z","updated":"2021-07-12T12:35:55.044Z","comments":true,"path":"2021/07/04/存在重复元素/","link":"","permalink":"https://tony2ty.github.io/2021/07/04/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","excerpt":"","text":"217. 存在重复元素难度：简单 给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 示例 3: 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 解题思路 常规算法，会导致超时 正确做法，先排序，然后比较相邻两个元素是否相等即可 代码 int cmpfunc (const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } bool containsDuplicate(int* nums, int numsSize){ if (nums == NULL) { return false; } int i, j; bool ret = false; qsort(nums, numsSize, sizeof(int), cmpfunc); for(i = 1; i &lt; numsSize; i++) { if (nums[i-1] == nums[i]) { ret = true; break; } } return ret; } 超时算法 bool containsDuplicate(int* nums, int numsSize){ if (nums == NULL) { return false; } int i, j; bool ret = false; for(i = 0; i &lt; numsSize; i++) { for(j = i + 1; j &lt; numsSize; j++) { if (nums[i] == nums[j]) { ret = true; break; } } } return ret; } 错误算法 原因是以数组值作为下标，但是不知道数组值的范围，则申请的数组size只能是int类型的最大值 bool containsDuplicate(int* nums, int numsSize){ if (nums == NULL) { return false; } bool ret = false; bool *buff = malloc(sizeof(bool) * numsSize); memset(buff, false, sizeof(bool) * numsSize); for(int i = 0; i &lt; numsSize; i++) { if (buff[nums[i]] == false) { buff[nums[i]] = true; } else { ret = true; break; } } return ret; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"二叉树的最大深度","slug":"二叉树的最大深度","date":"2021-07-04T12:24:02.000Z","updated":"2021-07-15T14:00:51.245Z","comments":true,"path":"2021/07/04/二叉树的最大深度/","link":"","permalink":"https://tony2ty.github.io/2021/07/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","excerpt":"","text":"104. 二叉树的最大深度难度：简单 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 解题思路：按层计算，将每一层的节点看则根节点，只要该节点存在子节点，则层数+1，从下往上依次递推。 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int maxDepth(struct TreeNode* root){ int depth1 = 0, depth2 = 0, depth; if (root == NULL) { return 0; } depth1 = maxDepth(root->left); depth2 = maxDepth(root->right); depth = (depth1 > depth2) ? depth1:depth2; return depth + 1; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"二叉树的中序遍历","slug":"二叉树的中序遍历","date":"2021-07-03T13:11:44.000Z","updated":"2021-07-15T14:00:51.228Z","comments":true,"path":"2021/07/03/二叉树的中序遍历/","link":"","permalink":"https://tony2ty.github.io/2021/07/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"94. 二叉树的中序遍历难度：简单 给定一个二叉树的根节点 root ，返回它的 中序 遍历。 示例 1： 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[2,1] 示例 5： 输入：root = [1,null,2] 输出：[1,2] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ //第一个版本，存在问题 void inorder1(struct TreeNode* root, int *buff, int *returnSize) { if (root == NULL) { return; } inorder1(root->left, buff, returnSize); buff[*returnSize] = root->val; returnSize++; //不应该是returnSize++，这是指针变量++，int类型+4 inorder1(root->right, buff, returnSize); } //第二个版本，存在问题，变量index获取*returnSize值的位置有问题，应该放在33行 void inorder2(struct TreeNode* root, int *buff, int *returnSize) { if (root == NULL) { return; } int index = *returnSize; inorder2(root->left, buff, returnSize); buff[index++] = root->val; (*returnSize) = index; inorder2(root->right, buff, returnSize); } void inorder(struct TreeNode* root, int *buff, int *returnSize) { if (root == NULL) { return; } printf(\"%d\\n\", *returnSize); inorder(root->left, buff, returnSize); buff[*returnSize] = root->val; (*returnSize) += 1; printf(\"%d\\n\", *returnSize); inorder(root->right, buff, returnSize); } /** * Note: The returned array must be malloced, assume caller calls free(). */ int* inorderTraversal(struct TreeNode* root, int* returnSize){ int *buff = malloc(sizeof(int) * 100); *returnSize = 0; inorder(root, buff, returnSize); return buff; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"IMX6ULLVBAT电流测量","slug":"IMX6ULLVBAT电流测试","date":"2021-03-31T02:12:00.000Z","updated":"2021-08-05T14:41:17.619Z","comments":true,"path":"2021/03/31/IMX6ULLVBAT电流测试/","link":"","permalink":"https://tony2ty.github.io/2021/03/31/IMX6ULLVBAT%E7%94%B5%E6%B5%81%E6%B5%8B%E8%AF%95/","excerpt":"","text":"IMX6ULL VBAT电流测试概述 主控 开发板 内核版本 imx6ul MYS-6ULX Linux 4.9.88 原理图 查看原理图可知，VDD_BAT通过接插件J2由外部电池供电（暂时没有供电)。 电流测试使用3.3V给VDD_BAT供电，并串入电流表， 断开主板供电测试，VDD_BAT电流为0.344mA。电流感觉明显偏大 原因VDD_BAT在芯片内部叫VDD_SNVS_IN，通过下图可知在VDD_HIGH_IN电压变为0时，VDD_SNVS_IN需要给LDO_SNVS（RTC）、OSC32K、SVNS、POR,PFD,CLKMON四个模块供电。Secure Non-Volatile Storage (SNVS)","categories":[{"name":"嵌入式Linux","slug":"嵌入式Linux","permalink":"https://tony2ty.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"}],"tags":[{"name":"IMX6ULL","slug":"IMX6ULL","permalink":"https://tony2ty.github.io/tags/IMX6ULL/"}]},{"title":"删除有序数组中的重复项","slug":"删除有序数组中的重复项","date":"2020-02-13T10:38:23.000Z","updated":"2021-07-12T12:29:24.791Z","comments":true,"path":"2020/02/13/删除有序数组中的重复项/","link":"","permalink":"https://tony2ty.github.io/2020/02/13/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"26. 删除有序数组中的重复项难度：简单 给你一个有序数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125; 示例 1： 输入：nums = [1,1,2] 输出：2, nums = [1,2] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按升序排列 代码 int removeDuplicates(int* nums, int numsSize){ int i, j = 0; if (numsSize &lt; 2) { return numsSize; } for (i = 1; i &lt; numsSize; i++) { if (nums[j] != nums[i]) { nums[++j] = nums[i]; } } return ++j; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"回文数","slug":"回文数","date":"2020-02-12T05:20:00.000Z","updated":"2021-07-12T12:32:07.929Z","comments":true,"path":"2020/02/12/回文数/","link":"","permalink":"https://tony2ty.github.io/2020/02/12/%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"","text":"9. 回文数难度：简单 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。 示例 1： 输入：x = 121 输出：true 示例 2： 输入：x = -121 输出：false 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3： 输入：x = 10 输出：false 解释：从右向左读, 为 01 。因此它不是一个回文数。 示例 4： 输入：x = -101 输出：false 提示： -231 &lt;= x &lt;= 231 - 1 进阶：你能不将整数转为字符串来解决这个问题吗？ 代码 bool isPalindrome(int x){ long t=0, m = x; if (m &lt; 0) { return false; } if (m &lt; 10) { return true; } if (m % 10 == 0) { return false; } while (m) { t = t * 10 + m % 10; m /= 10; if (t > 0x7fffffff) { break; } } printf(\"t=%d %d\\r\\n\", t, x); return (x == t); }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"最长回文子串","slug":"最长回文子串","date":"2020-02-12T03:35:54.000Z","updated":"2021-07-12T12:24:11.616Z","comments":true,"path":"2020/02/12/最长回文子串/","link":"","permalink":"https://tony2ty.github.io/2020/02/12/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"5. 最长回文子串难度：中等 给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = &quot;babad&quot; 输出：&quot;bab&quot; 解释：&quot;aba&quot; 同样是符合题意的答案。 示例 2： 输入：s = &quot;cbbd&quot; 输出：&quot;bb&quot; 示例 3： 输入：s = &quot;a&quot; 输出：&quot;a&quot; 示例 4： 输入：s = &quot;ac&quot; 输出：&quot;a&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 仅由数字和英文字母（大写和/或小写）组成 代码 char * longestPalindrome(char * s){ int startIndex = 0; int cur1Index; int cur2Index; int cur3Index; bool cur1_flag = true; bool cur2_flag = true; bool cur3_flag = true; char *tar = NULL; int i = 1, j =0, m = 0, k1,k2,k3,n1,n2,n3; int maxLen = 1; int cur1Len = 0; int cur2Len = 0; int cur3Len = 0; int str_len = strlen(s); if (s == NULL) { return NULL; } if ((str_len == 0) || (str_len == 1)) { return s; } while (i &lt; str_len) { #if 0 for (j = i, m = i; j >= 0, m &lt; str_len; j--, m++) { if (cur1_flag == true) { k1 = j - 1; n1 = m; if ((k1 &lt; 0) || (n1 >= str_len)) { cur1_flag = false; } if (cur1_flag == true) { if (s[k1] == s[n1]) { cur1Len = n1 - k1 + 1; cur1Index = k1; } else { cur1_flag = false; } } } if (cur2_flag == true) { k2 = j - 1; n2 = m + 1; if ((k2 &lt; 0) || (n2 >= str_len)) { cur2_flag = false; } if (cur2_flag == true) { if (s[k2] == s[n2]) { cur2Len = n2 - k2 + 1; cur2Index = k2; } else { cur2_flag = false; } } } if (cur3_flag == true) { k3 = j; n3 = m + 1; if ((k3 &lt; 0) || (n3 >= str_len)) { cur3_flag = false; } if (cur3_flag == true) { if (s[k3] == s[n3]) { cur3Len = n3 - k3 + 1; cur3Index = k3; } else { cur3_flag = false; } } } } i++; cur1_flag = true; cur2_flag = true; cur2_flag = true; #else for (j = i - 1, m = i; j >= 0, m &lt; str_len; j--, m++) { // printf(\"1i=%d j=%d m=%d\\r\\n\", i, j, m); if (j &lt; 0) { break; } if (s[j] == s[m]) { cur3Len = m - j + 1; cur3Index = j; } else { break; } } for (j = i - 1, m = i + 1; j >= 0, m &lt; str_len; j--, m++) { // printf(\"2i=%d j=%d m=%d\\r\\n\", i, j, m); if (j &lt; 0) { break; } if (s[j] == s[m]) { cur1Len = m - j + 1; cur1Index = j; } else { break; } } for (j = i, m = i + 1; j >= 0, m &lt; str_len; j--, m++) { // printf(\"3i=%d j=%d m=%d\\r\\n\", i, j, m); if (j &lt; 0) { break; } if (s[j] == s[m]) { cur2Len = m - j + 1; cur2Index = j; } else { break; } } i++; #endif if (cur1Len > maxLen) { maxLen = cur1Len; startIndex = cur1Index; } if (cur2Len > maxLen) { maxLen = cur2Len; startIndex = cur2Index; } if (cur3Len > maxLen) { maxLen = cur3Len; startIndex = cur3Index; } } tar = (char *)malloc(maxLen+1); for (i = 0; i &lt; maxLen; i++) { tar[i] = s[startIndex + i]; } tar[maxLen] = '\\0'; return tar; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"nrf52832广播时加入自定义UUID","slug":"nrf52832广播时加入自定义UUID","date":"2019-12-26T08:49:14.000Z","updated":"2021-07-12T12:36:50.254Z","comments":true,"path":"2019/12/26/nrf52832广播时加入自定义UUID/","link":"","permalink":"https://tony2ty.github.io/2019/12/26/nrf52832%E5%B9%BF%E6%92%AD%E6%97%B6%E5%8A%A0%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89UUID/","excerpt":"","text":"nrf52832广播时加入自定义UUID广播中包含自定义服务UUID与包含标准服务UUID是有所区别的，区别是数据长度不一致 标准服务UUID，长度为2个字节 自定义服务UUID，长度为16个字节 在SCAN_RSP扫描响应中加入自定义UUID","categories":[{"name":"BLE","slug":"BLE","permalink":"https://tony2ty.github.io/categories/BLE/"}],"tags":[{"name":"NRF52832","slug":"NRF52832","permalink":"https://tony2ty.github.io/tags/NRF52832/"}]},{"title":"整数反转","slug":"整数反转","date":"2019-12-25T01:05:01.000Z","updated":"2021-07-12T12:25:48.277Z","comments":true,"path":"2019/12/25/整数反转/","link":"","permalink":"https://tony2ty.github.io/2019/12/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"7. 整数反转难度：简单 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123 输出：321 示例 2： 输入：x = -123 输出：-321 示例 3： 输入：x = 120 输出：21 示例 4： 输入：x = 0 输出：0 提示： -231 &lt;= x &lt;= 231 - 1 实现int reverse(int x){ long y = 0; bool is_posit = true; if (x &lt; 0) { is_posit = false; // b = abs(x); x &amp;= 0x7fffffff; x = x - 1; x = ~x; x &amp;= 0x7fffffff; } //printf(\"%d\\n\", x); // while (((x % 10) != 0) || (x >= 10)) while (x) { y *= 10; y += x % 10; x /= 10; } if (y > 0x7fffffff) { // printf(\"aaa\\n\"); return 0; } if (is_posit) { x = y; } else { // printf(\"%d\\n\", y); x = -y; } return x; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"字符串转换整数","slug":"字符串转换整数","date":"2019-12-25T00:47:02.000Z","updated":"2021-07-12T12:24:37.704Z","comments":true,"path":"2019/12/25/字符串转换整数/","link":"","permalink":"https://tony2ty.github.io/2019/12/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/","excerpt":"","text":"8. 字符串转换整数 (atoi)难度：中等 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意： 本题中的空白字符只包括空格字符 &#39; &#39; 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 示例 1： 输入：s = &quot;42&quot; 输出：42 解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。 第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格） ^ 第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;） ^ 第 3 步：&quot;42&quot;（读入 &quot;42&quot;） ^ 解析得到整数 42 。 由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。 示例 2： 输入：s = &quot; -42&quot; 输出：-42 解释： 第 1 步：&quot; -42&quot;（读入前导空格，但忽视掉） ^ 第 2 步：&quot; -42&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数） ^ 第 3 步：&quot; -42&quot;（读入 &quot;42&quot;） ^ 解析得到整数 -42 。 由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。 示例 3： 输入：s = &quot;4193 with words&quot; 输出：4193 解释： 第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格） ^ 第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;） ^ 第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止） ^ 解析得到整数 4193 。 由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。 示例 4： 输入：s = &quot;words and 987&quot; 输出：0 解释： 第 1 步：&quot;words and 987&quot;（当前没有读入字符，因为没有前导空格） ^ 第 2 步：&quot;words and 987&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;） ^ 第 3 步：&quot;words and 987&quot;（由于当前字符 &#39;w&#39; 不是一个数字，所以读入停止） ^ 解析得到整数 0 ，因为没有读入任何数字。 由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。 示例 5： 输入：s = &quot;-91283472332&quot; 输出：-2147483648 解释： 第 1 步：&quot;-91283472332&quot;（当前没有读入字符，因为没有前导空格） ^ 第 2 步：&quot;-91283472332&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数） ^ 第 3 步：&quot;-91283472332&quot;（读入 &quot;91283472332&quot;） ^ 解析得到整数 -91283472332 。 由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。 提示： 0 &lt;= s.length &lt;= 200 s 由英文字母（大写和小写）、数字（0-9）、&#39; &#39;、&#39;+&#39;、&#39;-&#39; 和 &#39;.&#39; 组成 编程实现int myAtoi(char * str){ long x = 0, y = 0; bool is_posit = true; bool first_symble = false; bool is_continue = false; if (str == NULL) { return 0; } while (*str) { if (*str != ' ') { if ((*str > '9') || (*str &lt; '0')) { if ((*str != '+') &amp;&amp; (*str != '-')) { break; } } if (first_symble == false) { if (((*str &lt;= '9') &amp;&amp; (*str >= '0')) || (*str == '+')) { is_posit = true; if (*str == '+') { str++; } } else if (*str == '-') { is_posit = false; str++; } first_symble = true; } if ((*str &lt;= '9') &amp;&amp; (*str >= '0')) { x *= 10; x += *str - 0x30; } else { break; } } else if (first_symble == true) { break; } str++; if (is_posit == false) { y = -x; } else { y = x; } if (y > 2147483647) { y = 2147483647; break; } else if (y &lt; -2147483648) { y = -2147483648; break; } } return y; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://tony2ty.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"无重复字符的最长字串","slug":"无重复字符的最长字串","date":"2019-12-12T09:17:47.000Z","updated":"2021-07-15T14:00:51.246Z","comments":true,"path":"2019/12/12/无重复字符的最长字串/","link":"","permalink":"https://tony2ty.github.io/2019/12/12/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/","excerpt":"","text":"3. 无重复字符的最长子串难度：中等 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 输入: s = &quot;bbbbb&quot; 输出: 1 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 输入: s = &quot;pwwkew&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 示例 4: 输入: s = &quot;&quot; 输出: 0 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 代码 int lengthOfLongestSubstring(char * s){ int len = strlen(s); int i, j, index; int step = 1; int max = 0; bool ret = false; if (len == 1) { return 1; } index = 0; for (i = 1; i &lt; len;i++) { ret = true; // printf(\"step1:%d %d\\r\\n\", i, index); for (j = index; j &lt; i; j++) { if (s[i] == s[j]) { step = 1; ret = false; index = j + 1; break; } } //printf(\"step2:%d %d\\r\\n\", i, index); if (ret) { step = i - index + 1; } //printf(\"step2:%d %d\\r\\n\", step, index); if (step > max) { max = step; } // step = 1; } return max; } int lengthOfLongestSubstring(char * s){ if (s == NULL) { return NULL; } int n = strlen(s); if (n &lt;= 1) { return n; } int i, j, val, max = 1, tmp = 1; for (i = 0, j = 1; j &lt; n; j++) { val = s[j]; for (int m = i; m &lt; j; m++) { if (val != s[m]) { tmp++; } else { i = m + 1; break; } } max = fmax(max, tmp); tmp = 1; } return max; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://tony2ty.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"两数相加","slug":"两数相加","date":"2019-12-04T08:50:13.000Z","updated":"2021-07-12T12:31:25.529Z","comments":true,"path":"2019/12/04/两数相加/","link":"","permalink":"https://tony2ty.github.io/2019/12/04/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"2. 两数相加难度：中等 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){ int step = 0; struct ListNode *l3 = (struct ListNode *)malloc(sizeof(struct ListNode)); struct ListNode *list_last = NULL; struct ListNode *target = NULL; int addr = 0; l3->next = NULL; target = l3; while ((l1 != NULL) || (l2 != NULL)) { if (l1 != NULL) { l3->val = l1->val; l1 = l1->next; // printf(\"l1: %d\\r\\n\", l3->val); } if (l2 != NULL) { l3->val += l2->val; l2 = l2->next; // printf(\"l2: %d\\r\\n\", l3->val); } l3->val += step; step = l3->val / 10; l3->val %= 10; list_last = l3; // printf(\"%d, %d, %p, %p\\r\\n\", l3->val, step, l3, list_last); l3->next = (struct ListNode *)malloc(sizeof(struct ListNode)); l3 = l3->next; l3->next = NULL; l3->val = 0; } // printf(\"%d, %p\\r\\n\", step, list_last); if (step != 0) { l3->val = step; l3->next = NULL; } else { free(list_last->next); list_last->next = NULL; } return target; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"两数之和","slug":"两数之和","date":"2019-12-03T12:16:07.000Z","updated":"2021-07-12T12:31:12.818Z","comments":true,"path":"2019/12/03/两数之和/","link":"","permalink":"https://tony2ty.github.io/2019/12/03/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"1. 两数之和难度：简单 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 代码 /** * Note: The returned array must be malloced, assume caller calls free(). */ int* twoSum(int* nums, int numsSize, int target, int* returnSize){ int *buff = malloc(sizeof(int) * 2); for (int i = 0; i &lt; numsSize; i ++) { for (int j = i + 1; j &lt; numsSize; j++) { if (nums[i] + nums[j] == target) { buff[0] = i; buff[1] = j; *returnSize = 2; break; } } } return buff; }","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"BC20 MQTT连接OneNet","slug":"BC20-MQTT连接OneNet","date":"2019-11-20T09:17:38.000Z","updated":"2021-07-12T12:37:48.608Z","comments":true,"path":"2019/11/20/BC20-MQTT连接OneNet/","link":"","permalink":"https://tony2ty.github.io/2019/11/20/BC20-MQTT%E8%BF%9E%E6%8E%A5OneNet/","excerpt":"","text":"BC20 MQTT连接OneNet平台使用串口调试助手AT命令方式驱动BC20模块 OneNet平台创建相关产品以及设备产品 设备![ScreenClip [2]](BC20-MQTT连接OneNet/ScreenClip [2].png) BC20设置 发送的命令 序号 命令 说明 1 AT+QMTCFG=”version”,0,4 配置MQTT选项参数 2 AT+QMTOPEN=0,”183.230.40.39”,6002 打开MQTT客户端 3 AT+QMTCONN=0,”571192984”,”296559”,”pub20191120” 客户端连接服务器 4 AT+QMTCLOSE=0 关闭MQTT客户端 5 AT+QMTDISC=0 客户端断开与服务器的连接 6 AT+QMTSUB=0,1,”dev0”,0 主题订阅 7 AT+QMTPUB=0,0,0,0,”dev0”,”hello MQTT.” 主题发布 平台下发数据![ScreenClip [3]](BC20-MQTT连接OneNet/ScreenClip [3].png) 终端接收数据![ScreenClip [4]](BC20-MQTT连接OneNet/ScreenClip [4].jpg) 平台发布订阅待实现","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://tony2ty.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"Onenet","slug":"Onenet","permalink":"https://tony2ty.github.io/tags/Onenet/"},{"name":"MQTT","slug":"MQTT","permalink":"https://tony2ty.github.io/tags/MQTT/"}]},{"title":"bin与hex文件的区别","slug":"bin与hex文件的区别","date":"2019-11-09T01:25:59.000Z","updated":"2021-07-12T12:37:29.593Z","comments":true,"path":"2019/11/09/bin与hex文件的区别/","link":"","permalink":"https://tony2ty.github.io/2019/11/09/bin%E4%B8%8Ehex%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"bin与hex文件的区别概述嵌入式系统中，在终端设备中运行的程序常用的两种格式：bin与hex格式。一般IDE（KEIL、IAR）都可以生成这两种格式。 个人之前一般使用bin格式。bin文件格式比较麻烦的一个问题就是需要知道程序下载的位置，即需要人为指定下载地址才可以。 在之前的开发过程中一直没有关注过，为啥非要搞出两种格式？直到上次使用J-FLASH 下载hex文件格式的文件时，发现居然不需要指定地址空间才发现原来hex有这个好处。于是研究了一下这两种格式的区别。 hex格式介绍hex文件格式是由intel提出的一种ASCII文本文件，hex文件每行包含一个hex记录。intel HEX文件中的每一行都包含一个HEX记录。这些记录由代表机器的十六进制数字组成语言代码和/或常量数据。英特尔HEX文件通常用于传输将存储在ROM或EPROM中的程序和数据。 一个intel hex 文件由许多hex记录组成， 未完待续！","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://tony2ty.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"可执行文件","slug":"可执行文件","permalink":"https://tony2ty.github.io/tags/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"}]},{"title":"ble空中包格式","slug":"ble空中包格式","date":"2019-11-04T13:33:01.000Z","updated":"2021-07-12T12:37:04.008Z","comments":true,"path":"2019/11/04/ble空中包格式/","link":"","permalink":"https://tony2ty.github.io/2019/11/04/ble%E7%A9%BA%E4%B8%AD%E5%8C%85%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"BLE空中包格式数据包格式广播通道包与数据通道包格式见下图 数据包包含前导（Preamble）、访问地址（Access Address）、PDU（）、CRC（校验）4个部分。 前导（Preamble） 类型 字节数 LE 1M PHY 1 LE 2M PHY 2 包传输时间是44~2120us。 前导的作用 接收端实现频率同步、符号定时评估与自动增益控制 前导数据与访问地址有关，前导码第一位与Access Address的LSB一致，LE 1M PHY取值为0x55或0xAA，见下图 访问地址广播通道所有广播通道数据包的访问地址都是0X8E89BED6 数据通道在两个设备建立连接后，访问地址是随机的，每次都不一样 PDU广播通道 数据通道CRC抓包数据参考VOL6 PartB：Link Layer Specification","categories":[{"name":"BLE","slug":"BLE","permalink":"https://tony2ty.github.io/categories/BLE/"}],"tags":[{"name":"BLE","slug":"BLE","permalink":"https://tony2ty.github.io/tags/BLE/"}]},{"title":"ONENET读取与控制麒麟座MINI开发板LED状态","slug":"ONENET读取与控制麒麟座MINI开发板LED状态","date":"2019-11-04T08:30:30.000Z","updated":"2021-07-12T12:36:38.502Z","comments":true,"path":"2019/11/04/ONENET读取与控制麒麟座MINI开发板LED状态/","link":"","permalink":"https://tony2ty.github.io/2019/11/04/ONENET%E8%AF%BB%E5%8F%96%E4%B8%8E%E6%8E%A7%E5%88%B6%E9%BA%92%E9%BA%9F%E5%BA%A7MINI%E5%BC%80%E5%8F%91%E6%9D%BFLED%E7%8A%B6%E6%80%81/","excerpt":"","text":"ONENET读取与控制麒麟座MINI开发板LED状态硬件麒麟座MINI开发板V1.4 嵌入式软件OneNET_Demo_ESP8266_EDP_Led 工程修改内容 led.c文件修改 函数LED_Init，mini开发板LED所在GPIO为PB6、PB7、PB8、PB9 函数LED_GetValue，mini开发板LED状态与IO口状态相反 /** * @brief LED指示灯初始化函数 **/ void LED_Init(void) { GPIO_InitTypeDef GPIO_InitStructure; //PB9--对应开发板红色指示灯;PB8--对应开发板绿色指示灯; //PB7--对应开发板黄色指示灯;PB6---对应开发板蓝色指示灯 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOB, &GPIO_InitStructure); } /** * @brief 获取LED的当前状态值 **/ void LED_GetValue(void) { if(GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_9)) { red_value=0; } else { red_value=1; } if(GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_6)) { blue_value=0; } else { blue_value=1; } if(GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_8)) { green_value=0; } else { green_value=1; } if(GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_7)) { yellow_value=0; } else { yellow_value=1; } } led.h文件修改 #define LED_RED_OFF GPIO_SetBits(GPIOB,GPIO_Pin_9) #define LED_GREEN_OFF GPIO_SetBits(GPIOB,GPIO_Pin_8) #define LED_YELLOW_OFF GPIO_SetBits(GPIOB,GPIO_Pin_7) #define LED_BLUE_OFF GPIO_SetBits(GPIOB,GPIO_Pin_6) #define LED_RED_ON GPIO_ResetBits(GPIOB,GPIO_Pin_9) #define LED_GREEN_ON GPIO_ResetBits(GPIOB,GPIO_Pin_8) #define LED_YELLOW_ON GPIO_ResetBits(GPIOB,GPIO_Pin_7) #define LED_BLUE_ON GPIO_ResetBits(GPIOB,GPIO_Pin_6) ESP8266.h文件修改 #define API_KEY \"DXZcCKxqrpxZJKWFnbMzxIjeITk=\" //API_KEY 需要修改为用户自己的对应参数 #define DEV_ID \"1078702\" //设备ID 需要修改为用户自己的对应参数 #define CWJAP \"AT+CWJAP=\\\"ONENET\\\",\\\"\\\"\\r\\n\" //ssid: onenet 密码：空 前两个宏定义OneNET平台相关，最后一个WIFI的SSID名称以及密码，这三个宏根据自己的需要修改 OneNET平台操作 设置GPIO状态 上述命令实现点亮blue led 读取GPIO状态 目前显示BLUE点亮，其他三个LED熄灭 参考 https://github.com/cm-heclouds/OneNET_demo_code_kylin/tree/master/OneNET_Demo_ESP8266_EDP_Led https://github.com/cm-heclouds/OneNET_demo_code_kylin/blob/master/OneNET_Demo_User_Guide.pdf","categories":[{"name":"Onenet","slug":"Onenet","permalink":"https://tony2ty.github.io/categories/Onenet/"}],"tags":[{"name":"Esp8266","slug":"Esp8266","permalink":"https://tony2ty.github.io/tags/Esp8266/"}]},{"title":"usb_msc枚举过程","slug":"usb-msc枚举过程","date":"2019-11-04T03:14:57.000Z","updated":"2021-07-12T12:36:15.094Z","comments":true,"path":"2019/11/04/usb-msc枚举过程/","link":"","permalink":"https://tony2ty.github.io/2019/11/04/usb-msc%E6%9E%9A%E4%B8%BE%E8%BF%87%E7%A8%8B/","excerpt":"","text":"usb msc 枚举过程概述 枚举是控制传输的过程 抓包过程获取设备描述符令牌包 数据包 握手包 获取配置描述符令牌包 数据包 握手包 获取配置接口端点描述符令牌包 数据包 握手包 问题 当前来看枚举过程起始的SETUP令牌包阶段，应该是IN令牌包，根据IN令牌包的要求，需要包含设备地址和端点号，目前来看并未包含？ 如何识别各种包的类型","categories":[{"name":"USB","slug":"USB","permalink":"https://tony2ty.github.io/categories/USB/"}],"tags":[{"name":"USB","slug":"USB","permalink":"https://tony2ty.github.io/tags/USB/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-01T12:38:42.000Z","updated":"2021-07-08T14:32:32.804Z","comments":true,"path":"2019/10/01/hello-world/","link":"","permalink":"https://tony2ty.github.io/2019/10/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"嵌入式Linux","slug":"嵌入式Linux","permalink":"https://tony2ty.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/"},{"name":"STM32","slug":"STM32","permalink":"https://tony2ty.github.io/categories/STM32/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://tony2ty.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://tony2ty.github.io/categories/leetcode/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://tony2ty.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"GCC","slug":"GCC","permalink":"https://tony2ty.github.io/categories/GCC/"},{"name":"树莓派","slug":"树莓派","permalink":"https://tony2ty.github.io/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"BLE","slug":"BLE","permalink":"https://tony2ty.github.io/categories/BLE/"},{"name":"Onenet","slug":"Onenet","permalink":"https://tony2ty.github.io/categories/Onenet/"},{"name":"USB","slug":"USB","permalink":"https://tony2ty.github.io/categories/USB/"}],"tags":[{"name":"IMX6ULL","slug":"IMX6ULL","permalink":"https://tony2ty.github.io/tags/IMX6ULL/"},{"name":"GPS","slug":"GPS","permalink":"https://tony2ty.github.io/tags/GPS/"},{"name":"数组","slug":"数组","permalink":"https://tony2ty.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"TIMER","slug":"TIMER","permalink":"https://tony2ty.github.io/tags/TIMER/"},{"name":"PWM","slug":"PWM","permalink":"https://tony2ty.github.io/tags/PWM/"},{"name":"二分查找法","slug":"二分查找法","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://tony2ty.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","permalink":"https://tony2ty.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"链表","slug":"链表","permalink":"https://tony2ty.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"散列表","slug":"散列表","permalink":"https://tony2ty.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"异或法","slug":"异或法","permalink":"https://tony2ty.github.io/tags/%E5%BC%82%E6%88%96%E6%B3%95/"},{"name":"gdb调试","slug":"gdb调试","permalink":"https://tony2ty.github.io/tags/gdb%E8%B0%83%E8%AF%95/"},{"name":"枚举法","slug":"枚举法","permalink":"https://tony2ty.github.io/tags/%E6%9E%9A%E4%B8%BE%E6%B3%95/"},{"name":"单调栈","slug":"单调栈","permalink":"https://tony2ty.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"双指针法","slug":"双指针法","permalink":"https://tony2ty.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"},{"name":"动态库","slug":"动态库","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"},{"name":"计数排序","slug":"计数排序","permalink":"https://tony2ty.github.io/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"name":"排序","slug":"排序","permalink":"https://tony2ty.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"动态规划","slug":"动态规划","permalink":"https://tony2ty.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://tony2ty.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"https://tony2ty.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"视频监控","slug":"视频监控","permalink":"https://tony2ty.github.io/tags/%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7/"},{"name":"线性排序","slug":"线性排序","permalink":"https://tony2ty.github.io/tags/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/"},{"name":"递归","slug":"递归","permalink":"https://tony2ty.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"栈","slug":"栈","permalink":"https://tony2ty.github.io/tags/%E6%A0%88/"},{"name":"二叉树","slug":"二叉树","permalink":"https://tony2ty.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"NRF52832","slug":"NRF52832","permalink":"https://tony2ty.github.io/tags/NRF52832/"},{"name":"Onenet","slug":"Onenet","permalink":"https://tony2ty.github.io/tags/Onenet/"},{"name":"MQTT","slug":"MQTT","permalink":"https://tony2ty.github.io/tags/MQTT/"},{"name":"可执行文件","slug":"可执行文件","permalink":"https://tony2ty.github.io/tags/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"},{"name":"BLE","slug":"BLE","permalink":"https://tony2ty.github.io/tags/BLE/"},{"name":"Esp8266","slug":"Esp8266","permalink":"https://tony2ty.github.io/tags/Esp8266/"},{"name":"USB","slug":"USB","permalink":"https://tony2ty.github.io/tags/USB/"}]}